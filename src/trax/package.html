<!-- CVS $Revision$ $Date$ -->
<html>
  <title>Transformations for XML (TRaX).</title>
  <body>
    <p>Defines a global interface for generating Templates and performing XML transformations.</p>
    
    <p>A Processor uses a SAX XMLReader and a TemplatesBuilder (a SAX ContentHandler) to process the transformation instructions
    and produce a Templates object. A Transformer applies the Templates object (with any input parameters and serializer
    OutputFormat properties) to the XML input and generates the content for a Result object.<p>
    <dl>
      <dt><b>Version: </b></dt><dd>Alpha, 0.5, March 20, 2000</dd>
      <dt><b>Author: </b></dt><dd><a href="mailto:scott_boag@lotus.com">Scott Boag</a>
                                  <dd>(with help from Keith Visco, Mike Kay, Oracle, Assaf Arkin, and many others)</dd>
      <dt><b>Goals: </b></dt><dd>
        <ul>
          <li>Define a vendor-neutral and language-neutral interface for tree 
              transformations that will allow an application to use any implementation.</li>
          <li>Support SAX 1, SAX 2, DOM Level 1, and the {@link org.xml.serialize.Serializer} interfaces.</li>
          <li>Provide a good model for concurent and optimized transformations.</li>
          <li>Provide a reasonable model for incremental processing.</li>
          <li>Provide a reasonable model for passing data from the calling application 
              to the transformation.</li>
        </ul>
      </dd>
    </dl>
    
    <h3>Usage Examples</h3>

    <p>See <a href="Examples.html#method_detail">Examples Page</a></p>

    <h3>The TRaX Interfaces</h3>
         
    <p>To create a Processor, call the factory interface on the trax.Processor class.  The actual Processor is 
       plugged into the platform either as a platform default or as specified by the org.xml.trax.Processor.[type] system
       property (org.xml.trax.Processor.xslt, for example, indicates an XSLT processor).</p>
       
    <p>The Processor and Transformer both provide SAX style getFeature/setFeature methods. For example, you can ask the
    Transformer whether it supports the "http://xml.org/trax/features/dom/input" feature before you attempt to process XML input
    submitted as a DOM tree.</p>
       
    <p>The Processor's primary purpose is to process transformation instructions, such as an XSLT stylesheet, into a threadsafe
     Templates object. The Processor can get these instructions from a SAX InputSource, a DOM tree, or a list of InputSources
     specified by an xml-stylesheet instruction in the XML source.</p>
       
    <p>The Templates object is a bag of instructions that tells the Transformer} how to transform a source tree.  It is meant 
    to be thread safe for concurrent use in multiple threads. Currently, the Templates object has just two methods:</p>
    <ul>
      <li>newTransformer() creates a Transformer object associated with the Templates object</li>
      <li>getOutputFormat() returns an org.xml.serialize.OutputFormat object that you may modify and hand in to the 
      Transformer object</li>      
    </ul>
       
    <p>The Transformer object represents a single transformation.  You can only use the Transformer object in one thread at 
       a time. You can pass parameters to the Transformer object, which will then be used during the transformation. You can 
       also set the OutputFormat, which overrides the properties obtained from the owning Templates object.  The primary
       Transformer method is transform(), which takes as input a SAX InputSource}.  But there are a couple of other ways to
       cause a transformation to occur.  You can use the transformNode() method to transform a DOM Node. You can also obtain 
       SAX parse event handler interfaces, such as DocumentHandler, which can then be used as SAX event catchers.  A
       Transformer is also a SAX XMLFilter, which resembles an XML reader/parser, except that it obtains its events from another
       XML reader rather than from a primary source like an XML document or database.  For example, you can use the Transformer
       as a  SAX XMLFilter to chain or pipe transformations. The Transformer also allows you to use a SAX XMLFilter
       polymorphicaly as a SAX XMLReader.</p>
       
     <p>The output of a transformation is specified via a Result object. This is very much like a SAX InputSource, except that
      it allows you to specify OutputStreams, Writers, or DOM Nodes.  To specify SAX output, simply use 
        the SAX XMLReader methods (the Transformer is also a SAX XMLReader), and call the transform() method that takes 
        only an InputSource (no Result object).</p>
       
    <h3>Design Patterns</h3>

    <p>For more detailed information on the patterns see the <a href="patterns.html">Design Patterns Document</a></p>
    <p>For open design issues, see the class and method headers.</p>
 </body>
</html>


