options {

	  
    STATIC = false;
    MULTI=false;
    // NODE_PACKAGE="org.apache.xpath.operations";
    NODE_PREFIX="";
    NODE_FACTORY=true; 
    VISITOR=true;     // invokes the JJTree Visitor support
    NODE_SCOPE_HOOK=false;
    NODE_USES_PARSER=true;
	
}


    PARSER_BEGIN(XPath)


package org.apache.xpath.impl.parser;
	
		
import java.util.Stack;

public class XPath {
      
    // Begin generated by etree.xsl:extra-parser-code 
    org.apache.xpath.patterns.FunctionPattern m_matchFunc = null; // short lived.

    int m_predLevel = 0;

    /**
     * Node factory for customized parser.  
     */
    NodeFactory m_nodeFactory;

    /**
     * Sets the node factory.  
     * @param nodeFactory to use.
     */
    public void setNodeFactory(NodeFactory nodeFactory) {      		
    	m_nodeFactory = nodeFactory;
    }

    /**
     * Returns the node factory.  
     * @return NodeFactory
     */
    public NodeFactory getNodeFactory() {
    	return m_nodeFactory;
    }

    /**
     * The "version" property as pertains to the XPath spec.
     * @serial
     */
    private double m_version;

    /**
     * Set the "version" property for XPath.
     *
     * @param v Value for the "version" property.
     */
    public void setVersion(double v)
    {
        m_version = v;
    }

    /**
     * Get the "version" property for XPath.
     *
     * @return The value of the "version" property.
     */
    public double getVersion()
    {
        return m_version;
    }
    // end generated by etree.xsl:extra-parser-code 

    

      boolean m_isMatchPattern = false;

		  Stack binaryTokenStack = new Stack();
		  
		  public Node createNode(int id) {
			  return null;
		  }
		  
		  
		  
		  public static void main(String args[])
		     throws Exception
		  {
         int numberArgsLeft = args.length;
         int argsStart = 0;
         boolean isMatchParser = false;
         if(numberArgsLeft > 0)
         {
           if(args[argsStart].equals("-match"))
           {
             isMatchParser = true;
             System.out.println("Match Pattern Parser");
             argsStart++;
             numberArgsLeft--;
           }
         }
		     if(numberArgsLeft > 0)
		    {
			try
			{
				for(int i = argsStart; i < args.length; i++)
				{
					System.out.println();
					System.out.println("Test["+i+"]: "+args[i]);
					XPath parser = new XPath(new java.io.StringBufferInputStream(args[i]));
          SimpleNode tree;
          if(isMatchParser)
          {
					tree = parser.MatchPattern();
          }
          else
          {
					tree = parser.XPath2();
          }
					((SimpleNode)tree.jjtGetChild(0)).dump("|") ;
				}
				System.out.println("Success!!!!");
			}
			catch(ParseException pe)
			{
				System.err.println(pe.getMessage());
			}
			return;
		   }
		    java.io.DataInputStream dinput = new java.io.DataInputStream(System.in);
		    while(true)
		    {
			  try
			  {
			      System.err.println("Type Expression: ");
			      String input =  dinput.readLine(); 
			      if(null == input || input.trim().length() == 0)
			        break;  
			      XPath parser = new XPath(new java.io.StringBufferInputStream(input));
          SimpleNode tree;
          if(isMatchParser)
          {
					tree = parser.MatchPattern();
          }
          else
          {
					tree = parser.XPath2();
          }
			      ((SimpleNode)tree.jjtGetChild(0)).dump("|") ;
			  }
			  catch(ParseException pe)
			  {
			  	System.err.println(pe.getMessage());
			  }
			  catch(Exception e)
			  {
			  	System.err.println(e.getMessage());
			  }
		    }		    
		  }
		}

    PARSER_END(XPath)

	

// jwr: why doesn't this use java.util.Stack() instead of java.util.Vector()?

TOKEN_MGR_DECLS : {
  private Stack stateStack = new Stack();
  static final int PARENMARKER = 2000;
  
  /**
   * Push the current state onto the state stack.
   */
  private void pushState()
  {
    stateStack.addElement(new Integer(curLexState));
  }
  
  /**
   * Push the given state onto the state stack.
   * @param state Must be a valid state.
   */
  private void pushState(int state)
  {
    stateStack.push(new Integer(state));
  }
  
  /**
   * Pop the state on the state stack, and switch to that state.
   */
  private void popState()
  {
    if (stateStack.size() == 0)
    {
      printLinePos();
    }

    int nextState = ((Integer) stateStack.pop()).intValue();
    if(nextState == PARENMARKER)
      printLinePos();
    SwitchTo(nextState);
  }

  /**
   * Push a parenthesis state.  This pushes, in addition to the 
   * lexical state value, a special marker that lets 
   * resetParenStateOrSwitch(int state)
   * know if it should pop and switch.  Used for the comma operator.
   */
  private void pushParenState(int commaState, int rparState)
  {
    stateStack.push(new Integer(rparState));
    stateStack.push(new Integer(commaState));
    stateStack.push(new Integer(PARENMARKER));
    SwitchTo(commaState);
  }


//  /**
//   * Push a parenthesis state.  This pushes, in addition to the 
//   * lexical state value, a special marker that lets 
//   * resetParenStateOrSwitch(int state)
//   * know if it should pop and switch.  Used for the comma operator.
//   */
//  private void pushParenState()
//  {
//    stateStack.push(new Integer(curLexState));
//    stateStack.push(new Integer(PARENMARKER));
//  }

  /**
   * If a PARENMARKER is on the stack, switch the state to 
   * the state underneath the marker.  Leave the stack in 
   * the same state.  If the stack is zero, do nothing.
   * @param state The state to switch to if the PARENMARKER is not found.
   */
  private void resetParenStateOrSwitch(int state)
  {
    if (stateStack.size() == 0)
    {
      SwitchTo(state);
      return;
    }

    int nextState = ((Integer) stateStack.peek()).intValue();
    if (PARENMARKER == nextState)
    {
      // Wait for right paren to do the pop!
      Integer intObj = (Integer) stateStack.elementAt(stateStack.size() - 2);
      nextState = intObj.intValue();
      SwitchTo(nextState);
    }
    else
      SwitchTo(state);
  }
  
//   /**
//    * Pop the lexical state stack two elements.
//    */
// private void popParenState()
//   {
//     if (stateStack.size() == 0)
//       return;
// 
//     int nextState = ((Integer) stateStack.peek()).intValue();
//     if (PARENMARKER == nextState)
//     {
//       stateStack.pop();
//       stateStack.pop();
//     }
//   }

  /**
   * Pop the lexical state stack two elements.
   */
  private void popParenState()
  {
    if (stateStack.size() == 0)
      return;

    int nextState = ((Integer) stateStack.peek()).intValue();
    if (PARENMARKER == nextState)
    {
      stateStack.pop();
      stateStack.pop();
      int rparState = ((Integer) stateStack.peek()).intValue();
      SwitchTo(rparState);
      stateStack.pop();
    }
  }

  /**
   * Print the current line position.
   */
  public void printLinePos()
  {
    System.err.println("Line: " + input_stream.getEndLine());
  }
}


		SimpleNode XPath2() :
		{}
		{
		  XPath()<EOF>
		  { return jjtThis ; }
		}
      
		SimpleNode MatchPattern() :
		{m_isMatchPattern = true;}
		{
		  Pattern()<EOF>
		  { return jjtThis ; }
		}
    <DEFAULT, OPERATOR>
TOKEN :
{
  < IntegerLiteral : <Digits> > : OPERATOR
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < DecimalLiteral : (("." <Digits>) | (<Digits> "." (["0" - "9"])*)) > : OPERATOR
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < DoubleLiteral : (("." <Digits>) | (<Digits> ("." (["0" - "9"])*)?)) ["e", "E"] (["+", "-"])? <Digits> > : OPERATOR
}

<DEFAULT, OPERATOR, NAMESPACEKEYWORD>
TOKEN :
{
  < StringLiteral : (("\"" ((("\"" "\"") | ~["\""]))* "\"") | ("'" ((("'" "'") | ~["'"]))* "'")) > : OPERATOR
}

<DEFAULT, OPERATOR, QNAME, NAMESPACEDECL, XMLSPACE_DECL, ITEMTYPE, NAMESPACEKEYWORD, VARNAME, ELEMENT_CONTENT>
SPECIAL_TOKEN :
{
  < ExprComment : "{--" (~["}"])* "--}" >
}

<DEFAULT, OPERATOR, QNAME, NAMESPACEDECL, XMLSPACE_DECL, ITEMTYPE, NAMESPACEKEYWORD, VARNAME>
SKIP:
{
  <<skip_>>
}

TOKEN :
{
  < #skip_ : ((<WhitespaceChar> | <ExprComment>))+  >
}

<DEFAULT, OPERATOR, QNAME, START_TAG, NAMESPACEDECL, ITEMTYPE, NAMESPACEKEYWORD, END_TAG>
TOKEN :
{
  < S : (<WhitespaceChar>)+  >
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisChild : "child" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisDescendant : "descendant" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisParent : "parent" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisAttribute : "attribute" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisSelf : "self" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisDescendantOrSelf : "descendant-or-self" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisAncestor : "ancestor" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisFollowingSibling : "following-sibling" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisPrecedingSibling : "preceding-sibling" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisFollowing : "following" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisPreceding : "preceding" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisNamespace : "namespace" (<skip_>)* "::" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < AxisAncestorOrSelf : "ancestor-or-self" (<skip_>)* "::" > : QNAME
}

<OPERATOR>
TOKEN :
{
  < Or : "or" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < And : "and" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Div : "div" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Idiv : "idiv" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Mod : "mod" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Multiply : "*" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < In : "in" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < InContext : "context" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Satisfies : "satisfies" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Return : "return" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Then : "then" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Else : "else" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < To : "to" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Intersect : "intersect" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Union : "union" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Except : "except" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Instanceof : "instance" (<skip_>)+ "of" > : ITEMTYPE
}

<OPERATOR>
TOKEN :
{
  < Castable : "castable" (<skip_>)+ "as" > : ITEMTYPE
}

<ITEMTYPE>
TOKEN :
{
  < Item : "item" > : DEFAULT
}

<ITEMTYPE>
TOKEN :
{
  < ElementType : "element" > : DEFAULT
}

<ITEMTYPE>
TOKEN :
{
  < AttributeType : "attribute" > : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < ElementQNameLbrace : "element" (<skip_>)+ <QName> (<skip_>)* "{" > { pushState(DEFAULT); } : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < AttributeQNameLbrace : "attribute" (<skip_>)+ <QName> (<skip_>)* "{" > { pushState(DEFAULT); } : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < ElementLbrace : "element" (<skip_>)* "{" > { pushState(DEFAULT); } : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < AttributeLbrace : "attribute" (<skip_>)* "{" > { pushState(DEFAULT); } : DEFAULT
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < DefaultCollationEquals : "default" (<skip_>)+ "collation" (<skip_>)+ "=" > : NAMESPACEDECL
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < DefaultElement : "default" (<skip_>)+ "element" > : NAMESPACEKEYWORD
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < DefaultFunction : "default" (<skip_>)+ "function" > : NAMESPACEKEYWORD
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < OfType : "of" (<skip_>)+ "type" > : QNAME
}

<ITEMTYPE>
TOKEN :
{
  < AtomicValue : "atomic" (<skip_>)+ "value" > : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < TypeQName : "type" (<skip_>)+ <QName> > : OPERATOR
}

<ITEMTYPE>
TOKEN :
{
  < Node : "node" > : DEFAULT
}

<ITEMTYPE>
TOKEN :
{
  < Empty : "empty" > : DEFAULT
}

TOKEN :
{
  < #Nmstart : (<Letter> | "_") >
}

TOKEN :
{
  < #Nmchar : (<Letter> | <CombiningChar> | <Extender> | <Digit> | "." | "-" | "_") >
}

<DEFAULT, QNAME>
TOKEN :
{
  < Star : "*" > : OPERATOR
}

<ITEMTYPE, QNAME, DEFAULT, OPERATOR>
TOKEN :
{
  < NCNameColonStar : <NCName> ":" "*" > : OPERATOR
}

<ITEMTYPE, QNAME, DEFAULT, OPERATOR>
TOKEN :
{
  < StarColonNCName : "*" ":" <NCName> > : OPERATOR
}

<DEFAULT, QNAME>
TOKEN :
{
  < Root : "/" > : QNAME
}

<DEFAULT, QNAME>
TOKEN :
{
  < RootDescendants : "//" > : QNAME
}

<OPERATOR>
TOKEN :
{
  < Slash : "/" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < SlashSlash : "//" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Equals : "=" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Is : "is" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < NotEquals : "!=" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < IsNot : "isnot" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < LtEquals : "<=" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < LtLt : "<<" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < GtEquals : ">=" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < GtGt : ">>" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < FortranEq : "eq" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < FortranNe : "ne" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < FortranGt : "gt" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < FortranGe : "ge" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < FortranLt : "lt" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < FortranLe : "le" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Lt : "<" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Gt : ">" > : DEFAULT
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < Minus : "-" > : DEFAULT
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < Plus : "+" > : DEFAULT
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < QMark : "?" > : DEFAULT
}

<OPERATOR>
TOKEN :
{
  < Vbar : "|" > : DEFAULT
}

<DEFAULT, OPERATOR, QNAME>
TOKEN :
{
  < Lpar : "(" > : DEFAULT
}

<DEFAULT, QNAME>
TOKEN :
{
  < At : "@" > : QNAME
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < Lbrack : "[" > : DEFAULT
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < Rbrack : "]" > : OPERATOR
}

<DEFAULT, OPERATOR, ITEMTYPE, QNAME>
TOKEN :
{
  < Rpar : ")" > : OPERATOR
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < Some : "some" (<skip_>)* <VariableIndicator> > : VARNAME
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < Every : "every" (<skip_>)* <VariableIndicator> > : VARNAME
}

<DEFAULT, OPERATOR>
TOKEN :
{
  < ForVariable : "for" (<skip_>)* <VariableIndicator> > : VARNAME
}

<DEFAULT>
TOKEN :
{
  < CastAs : "cast" (<skip_>)+ "as" > : ITEMTYPE
}

<DEFAULT>
TOKEN :
{
  < TreatAs : "treat" (<skip_>)+ "as" > : ITEMTYPE
}

<DEFAULT, OPERATOR, ITEMTYPE>
TOKEN :
{
  < ValidateLbrace : "validate" (<skip_>)* "{" > { pushState(DEFAULT); } : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < ValidateContext : "validate" (<skip_>)+ "context" > : DEFAULT
}

TOKEN :
{
  < #Digits : (["0" - "9"])+  >
}

<ITEMTYPE>
TOKEN :
{
  < Comment : "comment" > : DEFAULT
}

<ITEMTYPE>
TOKEN :
{
  < Document : "document" > : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < DocumentLbrace : "document" (<skip_>)* "{" > { pushState(DEFAULT); } : DEFAULT
}

<ITEMTYPE>
TOKEN :
{
  < Text : "text" > : DEFAULT
}

<ITEMTYPE>
TOKEN :
{
  < Untyped : "untyped" > : DEFAULT
}

<ITEMTYPE>
TOKEN :
{
  < ProcessingInstruction : "processing-instruction" > : DEFAULT
}

<QNAME, DEFAULT>
TOKEN :
{
  < NodeLpar : "node" (<skip_>)* "(" > : DEFAULT
}

<QNAME, DEFAULT>
TOKEN :
{
  < CommentLpar : "comment" (<skip_>)* "(" > : DEFAULT
}

<QNAME, DEFAULT>
TOKEN :
{
  < TextLpar : "text" (<skip_>)* "(" > : DEFAULT
}

<QNAME, DEFAULT>
TOKEN :
{
  < ProcessingInstructionLpar : "processing-instruction" (<skip_>)* "(" > : DEFAULT
}

<DEFAULT>
TOKEN :
{
  < IfLpar : "if" (<skip_>)* "(" > : DEFAULT
}

<OPERATOR, DEFAULT, QNAME>
TOKEN :
{
  < Comma : "," > { resetParenStateOrSwitch(DEFAULT); }
}

<ITEMTYPE, QNAME, DEFAULT, OPERATOR>
TOKEN :
{
  < Dot : "." > : OPERATOR
}

<ITEMTYPE, QNAME, DEFAULT, OPERATOR>
TOKEN :
{
  < DotDot : ".." > : OPERATOR
}

TOKEN :
{
  < #NCName : <Nmstart> (<Nmchar>)* >
}

TOKEN :
{
  < #Prefix : <NCName> >
}

TOKEN :
{
  < #LocalPart : <NCName> >
}

<DEFAULT, OPERATOR, ITEMTYPE, QNAME>
TOKEN :
{
  < VariableIndicator : "$" > : VARNAME
}

<VARNAME>
TOKEN :
{
  < VarName : <QName> > : OPERATOR
}

<ITEMTYPE, QNAME, DEFAULT, OPERATOR>
TOKEN :
{
  < QName : (<Prefix> ":")? <LocalPart> > : OPERATOR
}

<DEFAULT>
TOKEN :
{
  < QNameLpar : <QName> (<skip_>)* "(" > : DEFAULT
}

void XPath()  :
{}
{
  [ExprSequence()]
}

void ExprSequence()  :
{}
{
  Expr() (<Comma> Expr())*
}

void Pattern()  :
{}
{
  PathPattern() [(<Union> | <Vbar>) Pattern()]
}

void PathPattern()  :
{}
{
  ((<Root>{jjtThis.processToken(token);} #Root(true) [RelativePathPattern()]) | (<RootDescendants>{jjtThis.processToken(token);} #RootDescendants(true) RelativePathPattern()) | (IdKeyPattern() [(<Slash> | <SlashSlash>{jjtThis.processToken(token);} #SlashSlash(true)) RelativePathPattern()]) | RelativePathPattern())
}

void RelativePathPattern()  #void :
{}
{
  PatternStep() [(<Slash> | <SlashSlash>{jjtThis.processToken(token);} #SlashSlash(true)) RelativePathPattern()]
}

void PatternStep()  :
{}
{
  [PatternAxis()] NodeTest() Predicates()
}

void PatternAxis()  #void :
{}
{
  (<AxisChild>{jjtThis.processToken(token);} #AxisChild(true) | <AxisAttribute>{jjtThis.processToken(token);} #AxisAttribute(true) | <At>{jjtThis.processToken(token);} #At(true))
}

void IdKeyPattern()  :
{}
{
  <QNameLpar>{jjtThis.processToken(token);} #QNameLpar(true) IdKeyValue() [<Comma> IdKeyValue()] <Rpar>
}

void IdKeyValue()  #void :
{}
{
  (<StringLiteral>{jjtThis.processToken(token);} #StringLiteral(true) | (<VariableIndicator> <VarName>{jjtThis.processToken(token);} #VarName(true)))
}

void Expr()  #void  :
{}
{
	OrExpr()
}

void OrExpr() #OrExpr(> 1) :
{}
{
  AndExpr() (<Or>
        
         {binaryTokenStack.push(token);}
			 AndExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #OrExpr(2))*
}

void AndExpr() #AndExpr(> 1) :
{}
{
  FLWRExpr() (<And>
        
         {binaryTokenStack.push(token);}
			 FLWRExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #AndExpr(2))*
}

void FLWRExpr() #FLWRExpr(> 1) :
{}
{
  (SimpleForClause() <Return>{jjtThis.processToken(token);} #Return(true))* QuantifiedExpr()
}

void QuantifiedExpr() #QuantifiedExpr(> 1) :
{}
{
  ((<Some>{jjtThis.processToken(token);} #Some(true) | <Every>{jjtThis.processToken(token);} #Every(true)) <VarName>{jjtThis.processToken(token);} #VarName(true)  <In>{jjtThis.processToken(token);} #In(true) Expr() (<Comma> (<VariableIndicator> <VarName>{jjtThis.processToken(token);} #VarName(true) ) <In>{jjtThis.processToken(token);} #In(true) Expr())* <Satisfies>{jjtThis.processToken(token);} #Satisfies(true))* IfExpr()
}

void IfExpr() #IfExpr(> 1) :
{}
{
  (<IfLpar>{jjtThis.processToken(token);} #IfLpar(true) Expr() <Rpar> <Then>{jjtThis.processToken(token);} #Then(true) Expr() <Else>{jjtThis.processToken(token);} #Else(true))* InstanceofExpr()
}

void InstanceofExpr() #InstanceofExpr(> 1) :
{}
{
  CastableExpr() (<Instanceof>{jjtThis.processToken(token);} #Instanceof(true) SequenceType())?
}

void CastableExpr() #CastableExpr(> 1) :
{}
{
  ComparisonExpr() (<Castable>{jjtThis.processToken(token);} #Castable(true) SingleType())?
}

void ComparisonExpr() #ComparisonExpr(> 1) :
{}
{
  RangeExpr() ((ValueComp() | GeneralComp() | NodeComp() | OrderComp()) RangeExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #ComparisonExpr(2))*
}

void RangeExpr() #RangeExpr(> 1) :
{}
{
  AdditiveExpr() (<To>
        
         {binaryTokenStack.push(token);}
			 AdditiveExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #RangeExpr(2))?
}

void AdditiveExpr() #AdditiveExpr(> 1) :
{}
{
  MultiplicativeExpr() ((<Plus>
        
         {binaryTokenStack.push(token);}
			 | <Minus>
        
         {binaryTokenStack.push(token);}
			) MultiplicativeExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #AdditiveExpr(2))*
}

void MultiplicativeExpr() #MultiplicativeExpr(> 1) :
{}
{
  UnaryExpr() ((<Multiply>
        
         {binaryTokenStack.push(token);}
			 | <Div>
        
         {binaryTokenStack.push(token);}
			 | <Idiv>
        
         {binaryTokenStack.push(token);}
			 | <Mod>
        
         {binaryTokenStack.push(token);}
			) UnaryExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #MultiplicativeExpr(2))*
}

void UnaryExpr() #UnaryExpr(keepUnary) :
{boolean keepUnary=false;}
{
  (<Minus>{keepUnary=true;jjtThis.processToken(token);} #Minus(true) | <Plus>{keepUnary=true;jjtThis.processToken(token);} #Plus(true))* UnionExpr()
}

void UnionExpr() #UnionExpr(> 1) :
{}
{
  IntersectExceptExpr() ((<Union>
        
         {binaryTokenStack.push(token);}
			 | <Vbar>
        
         {binaryTokenStack.push(token);}
			) IntersectExceptExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #UnionExpr(2))*
}

void IntersectExceptExpr() #IntersectExceptExpr(> 1) :
{}
{
  ValueExpr() ((<Intersect>
        
         {binaryTokenStack.push(token);}
			 | <Except>
        
         {binaryTokenStack.push(token);}
			) ValueExpr()
		{
         try
         {
		       jjtThis.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
		}
		 #IntersectExceptExpr(2))*
}

void ValueExpr() #void :
{}
{
  (ValidateExpr() | CastExpr() | TreatExpr() | PathExpr())
}

void PathExpr()  #PathExpr(>0) :
{}
{
  ((<Root>{jjtThis.processToken(token);} #Root(true) [RelativePathExpr()]) | (<RootDescendants>{jjtThis.processToken(token);} #RootDescendants(true) RelativePathExpr()) | RelativePathExpr())
}

void RelativePathExpr()  #void :
{}
{
  StepExpr() ((<Slash> | <SlashSlash>{jjtThis.processToken(token);} #SlashSlash(true)) StepExpr())*
}

void StepExpr()  #StepExpr(>1 || isStep) :
{boolean isStep=false;}
{
  (ForwardStep(){isStep=true;} | ReverseStep(){isStep=true;} | PrimaryExpr()) Predicates()
}

void SimpleForClause()  #void :
{}
{
  <ForVariable> <VarName>{jjtThis.processToken(token);} #VarName(true) <In>{jjtThis.processToken(token);} #In(true) Expr() (<Comma> (<VariableIndicator> <VarName>{jjtThis.processToken(token);} #VarName(true)) <In>{jjtThis.processToken(token);} #In(true) Expr())*
}

void ValidateExpr()  :
{}
{
  (<ValidateLbrace>{jjtThis.processToken(token);} #ValidateLbrace(true) | (<ValidateContext>{jjtThis.processToken(token);} #ValidateContext(true) SchemaGlobalContext() (<Slash>{jjtThis.processToken(token);} #Slash(true) SchemaContextStep())* <LbraceExprEnclosure>{jjtThis.processToken(token);} #LbraceExprEnclosure(true))) Expr() <Rbrace>{jjtThis.processToken(token);} #Rbrace(true)
}

void CastExpr()  :
{}
{
  (<CastAs>{jjtThis.processToken(token);} #CastAs(true) SingleType()) ParenthesizedExpr()
}

void TreatExpr()  :
{}
{
  (<TreatAs>{jjtThis.processToken(token);} #TreatAs(true) SequenceType()) ParenthesizedExpr()
}

void GeneralComp()  #void :
{}
{
  (<Equals>
        
         {binaryTokenStack.push(token);}
			 | <NotEquals>
        
         {binaryTokenStack.push(token);}
			 | <Lt>
        
         {binaryTokenStack.push(token);}
			 | <LtEquals>
        
         {binaryTokenStack.push(token);}
			 | <Gt>
        
         {binaryTokenStack.push(token);}
			 | <GtEquals>
        
         {binaryTokenStack.push(token);}
			)
}

void ValueComp()  #void :
{}
{
  (<FortranEq>
        
         {binaryTokenStack.push(token);}
			 | <FortranNe>
        
         {binaryTokenStack.push(token);}
			 | <FortranLt>
        
         {binaryTokenStack.push(token);}
			 | <FortranLe>
        
         {binaryTokenStack.push(token);}
			 | <FortranGt>
        
         {binaryTokenStack.push(token);}
			 | <FortranGe>
        
         {binaryTokenStack.push(token);}
			)
}

void NodeComp()  #void :
{}
{
  (<Is>
        
         {binaryTokenStack.push(token);}
			 | <IsNot>
        
         {binaryTokenStack.push(token);}
			)
}

void OrderComp()  #void :
{}
{
  (<LtLt>
        
         {binaryTokenStack.push(token);}
			 | <GtGt>
        
         {binaryTokenStack.push(token);}
			)
}

void PrimaryExpr()  #void :
{}
{
  (Literal() | FunctionCall() | (<VariableIndicator> <VarName>{jjtThis.processToken(token);} #VarName(true)) | ParenthesizedExpr())
}

void ForwardAxis()  #void :
{}
{
  (<AxisChild>{jjtThis.processToken(token);} #AxisChild(true) | <AxisDescendant>{jjtThis.processToken(token);} #AxisDescendant(true) | <AxisAttribute>{jjtThis.processToken(token);} #AxisAttribute(true) | <AxisSelf>{jjtThis.processToken(token);} #AxisSelf(true) | <AxisDescendantOrSelf>{jjtThis.processToken(token);} #AxisDescendantOrSelf(true) | <AxisFollowingSibling>{jjtThis.processToken(token);} #AxisFollowingSibling(true) | <AxisFollowing>{jjtThis.processToken(token);} #AxisFollowing(true) | <AxisNamespace>{jjtThis.processToken(token);} #AxisNamespace(true))
}

void ReverseAxis()  #void :
{}
{
  (<AxisParent>{jjtThis.processToken(token);} #AxisParent(true) | <AxisAncestor>{jjtThis.processToken(token);} #AxisAncestor(true) | <AxisPrecedingSibling>{jjtThis.processToken(token);} #AxisPrecedingSibling(true) | <AxisPreceding>{jjtThis.processToken(token);} #AxisPreceding(true) | <AxisAncestorOrSelf>{jjtThis.processToken(token);} #AxisAncestorOrSelf(true))
}

void NodeTest()  :
{}
{
  (KindTest() | NameTest())
}

void NameTest()  :
{}
{
  (<QName>{jjtThis.processToken(token);} #QName(true) | Wildcard())
}

void Wildcard()  #void :
{}
{
  (<Star>{jjtThis.processToken(token);} #Star(true) | <NCNameColonStar>{jjtThis.processToken(token);} #NCNameColonStar(true) | <StarColonNCName>{jjtThis.processToken(token);} #StarColonNCName(true))
}

void KindTest()  #void :
{}
{
  (ProcessingInstructionTest() | CommentTest() | TextTest() | AnyKindTest())
}

void ProcessingInstructionTest()  :
{}
{
  <ProcessingInstructionLpar> [<StringLiteral>{jjtThis.processToken(token);} #StringLiteral(true)] <Rpar>
}

void CommentTest()  :
{}
{
  <CommentLpar> <Rpar>
}

void TextTest()  :
{}
{
  <TextLpar> <Rpar>
}

void AnyKindTest()  :
{}
{
  <NodeLpar> <Rpar>
}

void ForwardStep()  #void :
{}
{
  ((ForwardAxis() (NodeTest())) | AbbreviatedForwardStep())
}

void ReverseStep()  #void :
{}
{
  ((ReverseAxis() (NodeTest())) | AbbreviatedReverseStep())
}

void AbbreviatedForwardStep()  #void :
{}
{
  (<Dot>{jjtThis.processToken(token);} #Dot(true) | (<At>{jjtThis.processToken(token);} #At(true) NameTest()) | NodeTest())
}

void AbbreviatedReverseStep()  #void :
{}
{
  <DotDot>{jjtThis.processToken(token);} #DotDot(true)
}

void Predicates()  #Predicates(> 0) :
{}
{
  (((<Lbrack> Expr() <Rbrack>)))*
}

void NumericLiteral()  #void :
{}
{
  (<IntegerLiteral>{jjtThis.processToken(token);} #IntegerLiteral(true) | <DecimalLiteral>{jjtThis.processToken(token);} #DecimalLiteral(true) | <DoubleLiteral>{jjtThis.processToken(token);} #DoubleLiteral(true))
}

void Literal()  #void :
{}
{
  (NumericLiteral() | <StringLiteral>{jjtThis.processToken(token);} #StringLiteral(true))
}

void ParenthesizedExpr()  #void :
{}
{
  <Lpar> [ExprSequence()]  <Rpar>
}

void FunctionCall()  :
{}
{
  <QNameLpar>{jjtThis.processToken(token);} #QNameLpar(true) [Expr() (<Comma> Expr())*] <Rpar>
}

void SchemaContext()  :
{}
{
  <InContext>{jjtThis.processToken(token);} #InContext(true) SchemaGlobalContext() (<Slash>{jjtThis.processToken(token);} #Slash(true) SchemaContextStep())*
}

void SchemaGlobalContext()  :
{}
{
  (<QName>{jjtThis.processToken(token);} #QName(true) | <TypeQName>{jjtThis.processToken(token);} #TypeQName(true))
}

void SchemaContextStep()  :
{}
{
  <QName>{jjtThis.processToken(token);} #QName(true)
}

void SingleType()  :
{}
{
  AtomicType() [<QMark>{jjtThis.processToken(token);} #QMark(true)]
}

void SequenceType()  :
{}
{
  ((ItemType() OccurrenceIndicator()) | <Empty>{jjtThis.processToken(token);} #Empty(true))
}

void ItemType()  :
{}
{
  (((<ElementType>{jjtThis.processToken(token);} #ElementType(true) | <AttributeType>{jjtThis.processToken(token);} #AttributeType(true)) [ElemOrAttrType()]) | <Node>{jjtThis.processToken(token);} #Node(true) | <ProcessingInstruction>{jjtThis.processToken(token);} #ProcessingInstruction(true) | <Comment>{jjtThis.processToken(token);} #Comment(true) | <Text>{jjtThis.processToken(token);} #Text(true) | (<Document>{jjtThis.processToken(token);} #Document(true)) | <Item>{jjtThis.processToken(token);} #Item(true) | AtomicType() | <Untyped>{jjtThis.processToken(token);} #Untyped(true) | <AtomicValue>{jjtThis.processToken(token);} #AtomicValue(true))
}

void ElemOrAttrType()  :
{}
{
  ((<QName>{jjtThis.processToken(token);} #QName(true) (SchemaType() | [SchemaContext()])) | SchemaType())
}

void SchemaType()  :
{}
{
  <OfType>{jjtThis.processToken(token);} #OfType(true) <QName>{jjtThis.processToken(token);} #QName(true)
}

void AtomicType()  :
{}
{
  <QName>{jjtThis.processToken(token);} #QName(true)
}

void OccurrenceIndicator()  :
{}
{
  [(<Star>{jjtThis.processToken(token);} #Star(true) | <Multiply>{jjtThis.processToken(token);} #Multiply(true) | <Plus>{jjtThis.processToken(token);} #Plus(true) | <QMark>{jjtThis.processToken(token);} #QMark(true))]
}

<START_TAG, END_TAG, ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
  < Lbrace : "{" > { pushState(); } : DEFAULT
}

<DEFAULT, OPERATOR, ITEMTYPE>
TOKEN :
{
  < LbraceExprEnclosure : "{" > { pushState(DEFAULT); } : DEFAULT
}

<QUOT_ATTRIBUTE_CONTENT, OPERATOR, DEFAULT>
TOKEN :
{
  < Rbrace : "}" > { popState(); }
}

<ELEMENT_CONTENT, CDATA_SECTION, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT, PROCESSING_INSTRUCTION_CONTENT, XML_COMMENT, XQUERY_COMMENT>
TOKEN :
{
  < Char : ["\t", "\r", "\n", "\u0020" - "\uFFFD"] >
}

TOKEN :
{
  < #WhitespaceChar : ["\t", "\r", "\n", " "] >
}

TOKEN :
{
  < #Letter : (<BaseChar> | <Ideographic>) >
}

TOKEN :
{
  < #BaseChar : ["\u0041" - "\u005a", "\u0061" - "\u007a", "\u00c0" - "\u00d6", "\u00d8" - "\u00f6", "\u00f8" - "\u00ff", "\u0100" - "\u0131", "\u0134" - "\u013e", "\u0141" - "\u0148", "\u014a" - "\u017e", "\u0180" - "\u01c3", "\u01cd" - "\u01f0", "\u01f4" - "\u01f5", "\u01fa" - "\u0217", "\u0250" - "\u02a8", "\u02bb" - "\u02c1", "\u0386", "\u0388" - "\u038a", "\u038c", "\u038e" - "\u03a1", "\u03a3" - "\u03ce", "\u03d0" - "\u03d6", "\u03da", "\u03dc", "\u03de", "\u03e0", "\u03e2" - "\u03f3", "\u0401" - "\u040c", "\u040e" - "\u044f", "\u0451" - "\u045c", "\u045e" - "\u0481", "\u0490" - "\u04c4", "\u04c7" - "\u04c8", "\u04cb" - "\u04cc", "\u04d0" - "\u04eb", "\u04ee" - "\u04f5", "\u04f8" - "\u04f9", "\u0531" - "\u0556", "\u0559", "\u0561" - "\u0586", "\u05d0" - "\u05ea", "\u05f0" - "\u05f2", "\u0621" - "\u063a", "\u0641" - "\u064a", "\u0671" - "\u06b7", "\u06ba" - "\u06be", "\u06c0" - "\u06ce", "\u06d0" - "\u06d3", "\u06d5", "\u06e5" - "\u06e6", "\u0905" - "\u0939", "\u093d", "\u0958" - "\u0961", "\u0985" - "\u098c", "\u098f" - "\u0990", "\u0993" - "\u09a8", "\u09aa" - "\u09b0", "\u09b2", "\u09b6" - "\u09b9", "\u09dc" - "\u09dd", "\u09df" - "\u09e1", "\u09f0" - "\u09f1", "\u0a05" - "\u0a0a", "\u0a0f" - "\u0a10", "\u0a13" - "\u0a28", "\u0a2a" - "\u0a30", "\u0a32" - "\u0a33", "\u0a35" - "\u0a36", "\u0a38" - "\u0a39", "\u0a59" - "\u0a5c", "\u0a5e", "\u0a72" - "\u0a74", "\u0a85" - "\u0a8b", "\u0a8d", "\u0a8f" - "\u0a91", "\u0a93" - "\u0aa8", "\u0aaa" - "\u0ab0", "\u0ab2" - "\u0ab3", "\u0ab5" - "\u0ab9", "\u0abd", "\u0ae0", "\u0b05" - "\u0b0c", "\u0b0f" - "\u0b10", "\u0b13" - "\u0b28", "\u0b2a" - "\u0b30", "\u0b32" - "\u0b33", "\u0b36" - "\u0b39", "\u0b3d", "\u0b5c" - "\u0b5d", "\u0b5f" - "\u0b61", "\u0b85" - "\u0b8a", "\u0b8e" - "\u0b90", "\u0b92" - "\u0b95", "\u0b99" - "\u0b9a", "\u0b9c", "\u0b9e" - "\u0b9f", "\u0ba3" - "\u0ba4", "\u0ba8" - "\u0baa", "\u0bae" - "\u0bb5", "\u0bb7" - "\u0bb9", "\u0c05" - "\u0c0c", "\u0c0e" - "\u0c10", "\u0c12" - "\u0c28", "\u0c2a" - "\u0c33", "\u0c35" - "\u0c39", "\u0c60" - "\u0c61", "\u0c85" - "\u0c8c", "\u0c8e" - "\u0c90", "\u0c92" - "\u0ca8", "\u0caa" - "\u0cb3", "\u0cb5" - "\u0cb9", "\u0cde", "\u0ce0" - "\u0ce1", "\u0d05" - "\u0d0c", "\u0d0e" - "\u0d10", "\u0d12" - "\u0d28", "\u0d2a" - "\u0d39", "\u0d60" - "\u0d61", "\u0e01" - "\u0e2e", "\u0e30", "\u0e32" - "\u0e33", "\u0e40" - "\u0e45", "\u0e81" - "\u0e82", "\u0e84", "\u0e87" - "\u0e88", "\u0e8a", "\u0e8d", "\u0e94" - "\u0e97", "\u0e99" - "\u0e9f", "\u0ea1" - "\u0ea3", "\u0ea5", "\u0ea7", "\u0eaa" - "\u0eab", "\u0ead" - "\u0eae", "\u0eb0", "\u0eb2" - "\u0eb3", "\u0ebd", "\u0ec0" - "\u0ec4", "\u0f40" - "\u0f47", "\u0f49" - "\u0f69", "\u10a0" - "\u10c5", "\u10d0" - "\u10f6", "\u1100", "\u1102" - "\u1103", "\u1105" - "\u1107", "\u1109", "\u110b" - "\u110c", "\u110e" - "\u1112", "\u113c", "\u113e", "\u1140", "\u114c", "\u114e", "\u1150", "\u1154" - "\u1155", "\u1159", "\u115f" - "\u1161", "\u1163", "\u1165", "\u1167", "\u1169", "\u116d" - "\u116e", "\u1172" - "\u1173", "\u1175", "\u119e", "\u11a8", "\u11ab", "\u11ae" - "\u11af", "\u11b7" - "\u11b8", "\u11ba", "\u11bc" - "\u11c2", "\u11eb", "\u11f0", "\u11f9", "\u1e00" - "\u1e9b", "\u1ea0" - "\u1ef9", "\u1f00" - "\u1f15", "\u1f18" - "\u1f1d", "\u1f20" - "\u1f45", "\u1f48" - "\u1f4d", "\u1f50" - "\u1f57", "\u1f59", "\u1f5b", "\u1f5d", "\u1f5f" - "\u1f7d", "\u1f80" - "\u1fb4", "\u1fb6" - "\u1fbc", "\u1fbe", "\u1fc2" - "\u1fc4", "\u1fc6" - "\u1fcc", "\u1fd0" - "\u1fd3", "\u1fd6" - "\u1fdb", "\u1fe0" - "\u1fec", "\u1ff2" - "\u1ff4", "\u1ff6" - "\u1ffc", "\u2126", "\u212a" - "\u212b", "\u212e", "\u2180" - "\u2182", "\u3041" - "\u3094", "\u30a1" - "\u30fa", "\u3105" - "\u312c", "\uac00" - "\ud7a3"] >
}

TOKEN :
{
  < #Ideographic : ["\u4e00" - "\u9fa5", "\u3007", "\u3021" - "\u3029"] >
}

TOKEN :
{
  < #CombiningChar : ["\u0300" - "\u0345", "\u0360" - "\u0361", "\u0483" - "\u0486", "\u0591" - "\u05a1", "\u05a3" - "\u05b9", "\u05bb" - "\u05bd", "\u05bf", "\u05c1" - "\u05c2", "\u05c4", "\u064b" - "\u0652", "\u0670", "\u06d6" - "\u06dc", "\u06dd" - "\u06df", "\u06e0" - "\u06e4", "\u06e7" - "\u06e8", "\u06ea" - "\u06ed", "\u0901" - "\u0903", "\u093c", "\u093e" - "\u094c", "\u094d", "\u0951" - "\u0954", "\u0962" - "\u0963", "\u0981" - "\u0983", "\u09bc", "\u09be", "\u09bf", "\u09c0" - "\u09c4", "\u09c7" - "\u09c8", "\u09cb" - "\u09cd", "\u09d7", "\u09e2" - "\u09e3", "\u0a02", "\u0a3c", "\u0a3e", "\u0a3f", "\u0a40" - "\u0a42", "\u0a47" - "\u0a48", "\u0a4b" - "\u0a4d", "\u0a70" - "\u0a71", "\u0a81" - "\u0a83", "\u0abc", "\u0abe" - "\u0ac5", "\u0ac7" - "\u0ac9", "\u0acb" - "\u0acd", "\u0b01" - "\u0b03", "\u0b3c", "\u0b3e" - "\u0b43", "\u0b47" - "\u0b48", "\u0b4b" - "\u0b4d", "\u0b56" - "\u0b57", "\u0b82" - "\u0b83", "\u0bbe" - "\u0bc2", "\u0bc6" - "\u0bc8", "\u0bca" - "\u0bcd", "\u0bd7", "\u0c01" - "\u0c03", "\u0c3e" - "\u0c44", "\u0c46" - "\u0c48", "\u0c4a" - "\u0c4d", "\u0c55" - "\u0c56", "\u0c82" - "\u0c83", "\u0cbe" - "\u0cc4", "\u0cc6" - "\u0cc8", "\u0cca" - "\u0ccd", "\u0cd5" - "\u0cd6", "\u0d02" - "\u0d03", "\u0d3e" - "\u0d43", "\u0d46" - "\u0d48", "\u0d4a" - "\u0d4d", "\u0d57", "\u0e31", "\u0e34" - "\u0e3a", "\u0e47" - "\u0e4e", "\u0eb1", "\u0eb4" - "\u0eb9", "\u0ebb" - "\u0ebc", "\u0ec8" - "\u0ecd", "\u0f18" - "\u0f19", "\u0f35", "\u0f37", "\u0f39", "\u0f3e", "\u0f3f", "\u0f71" - "\u0f84", "\u0f86" - "\u0f8b", "\u0f90" - "\u0f95", "\u0f97", "\u0f99" - "\u0fad", "\u0fb1" - "\u0fb7", "\u0fb9", "\u20d0" - "\u20dc", "\u20e1", "\u302a" - "\u302f", "\u3099", "\u309a"] >
}

TOKEN :
{
  < #Digit : ["\u0030" - "\u0039", "\u0660" - "\u0669", "\u06f0" - "\u06f9", "\u0966" - "\u096f", "\u09e6" - "\u09ef", "\u0a66" - "\u0a6f", "\u0ae6" - "\u0aef", "\u0b66" - "\u0b6f", "\u0be7" - "\u0bef", "\u0c66" - "\u0c6f", "\u0ce6" - "\u0cef", "\u0d66" - "\u0d6f", "\u0e50" - "\u0e59", "\u0ed0" - "\u0ed9", "\u0f20" - "\u0f29"] >
}

TOKEN :
{
  < #Extender : ["\u00b7", "\u02d0", "\u02d1", "\u0387", "\u0640", "\u0e46", "\u0ec6", "\u3005", "\u3031" - "\u3035", "\u309d" - "\u309e", "\u30fc" - "\u30fe"] >
}

