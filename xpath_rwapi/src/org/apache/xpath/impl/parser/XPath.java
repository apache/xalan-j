/* Generated By:JJTree&JavaCC: Do not edit this line. XPath.java */
package org.apache.xpath.impl.parser;

import java.io.*;
import java.util.Stack;

public class XPath/*@bgen(jjtree)*/implements XPathTreeConstants, XPathConstants {/*@bgen(jjtree)*/
  protected JJTXPathState jjtree = new JJTXPathState();
    // Begin generated by etree.xsl:extra-parser-code 

    int m_predLevel = 0;

    /**
     * Node factory for customized parser.  
     */
    private NodeFactory m_nodeFactory;

    /**
     * Returns the node factory.  
     * @return NodeFactory
     */
    public NodeFactory getNodeFactory() {
        if (m_nodeFactory == null)
        {
                m_nodeFactory = DefaultNodeFactory.createNodeFactory();
        }
        return m_nodeFactory;
    }


    /**
     * The "version" property as pertains to the XPath spec.
     * @serial
     */
    private double m_version;

    /**
     * Set the "version" property for XPath.
     *
     * @param v Value for the "version" property.
     */
    public void setVersion(double v)
    {
        m_version = v;
    }

    /**
     * Get the "version" property for XPath.
     *
     * @return The value of the "version" property.
     */
    public double getVersion()
    {
        return m_version;
    }
    // end generated by etree.xsl:extra-parser-code 



      boolean m_isMatchPattern = false;
      boolean isStep = false;
                  Stack binaryTokenStack = new Stack();

                  public Node createNode(int id) {
                          return null;
                  }



                  public static void main(String args[])
                     throws Exception
                  {
         int numberArgsLeft = args.length;
         int argsStart = 0;
         boolean isMatchParser = false;
         if(numberArgsLeft > 0)
         {
           if(args[argsStart].equals("-match"))
           {
             isMatchParser = true;
             System.out.println("Match Pattern Parser");
             argsStart++;
             numberArgsLeft--;
           }
         }
                     if(numberArgsLeft > 0)
                    {
                        try
                        {
        final boolean dumpTree = true;
        if(args[0].endsWith(".xquery"))
        {
          System.out.println("Running test for: "+args[0]);
          File file = new File(args[0]);
          FileInputStream fis = new FileInputStream(file);
          XPath parser = new XPath(fis);
          SimpleNode tree = parser.XPath2();
          if(dumpTree)
            tree.dump("|") ;
        }
        else
        {
                                for(int i = argsStart; i < args.length; i++)
                                {
                                        System.out.println();
                                        System.out.println("Test["+i+"]: "+args[i]);
                                        XPath parser = new XPath(new java.io.StringBufferInputStream(args[i]));
          SimpleNode tree;
          if(isMatchParser)
          {
                                        tree = parser.MatchPattern();
          }
          else
          {
                                        tree = parser.XPath2();
          }
                                        ((SimpleNode)tree.jjtGetChild(0)).dump("|") ;
                                }
                                System.out.println("Success!!!!");
        }
                        }
                        catch(ParseException pe)
                        {
                                System.err.println(pe.getMessage());
                        }
                        return;
                   }
                    java.io.DataInputStream dinput = new java.io.DataInputStream(System.in);
                    while(true)
                    {
                          try
                          {
                              System.err.println("Type Expression: ");
                              String input =  dinput.readLine();
                              if(null == input || input.trim().length() == 0)
                                break;
                              XPath parser = new XPath(new java.io.StringBufferInputStream(input));
          SimpleNode tree;
          if(isMatchParser)
          {
                                        tree = parser.MatchPattern();
          }
          else
          {
                                        tree = parser.XPath2();
          }
                              ((SimpleNode)tree.jjtGetChild(0)).dump("|") ;
                          }
                          catch(ParseException pe)
                          {
                                System.err.println(pe.getMessage());
                          }
                          catch(Exception e)
                          {
                                System.err.println(e.getMessage());
                          }
                    }
                  }

  final public SimpleNode XPath2() throws ParseException {
                 /*@bgen(jjtree) XPath2 */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTXPATH2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      XPath();
      jj_consume_token(0);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
                    if (jjtc000) {
                      jjtree.clearNodeScope(jjtn000);
                      jjtc000 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte000 instanceof RuntimeException) {
                      {if (true) throw (RuntimeException)jjte000;}
                    }
                    if (jjte000 instanceof ParseException) {
                      {if (true) throw (ParseException)jjte000;}
                    }
                    {if (true) throw (Error)jjte000;}
    } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
    }
    throw new Error("Missing return statement in function");
  }

  final public SimpleNode MatchPattern() throws ParseException {
                 /*@bgen(jjtree) MatchPattern */
                 SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTMATCHPATTERN);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);m_isMatchPattern = true;
    try {
      Pattern();
      jj_consume_token(0);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    {if (true) return jjtn000 ;}
    } catch (Throwable jjte000) {
                    if (jjtc000) {
                      jjtree.clearNodeScope(jjtn000);
                      jjtc000 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte000 instanceof RuntimeException) {
                      {if (true) throw (RuntimeException)jjte000;}
                    }
                    if (jjte000 instanceof ParseException) {
                      {if (true) throw (ParseException)jjte000;}
                    }
                    {if (true) throw (Error)jjte000;}
    } finally {
                    if (jjtc000) {
                      jjtree.closeNodeScope(jjtn000, true);
                    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void XPath() throws ParseException {
 /*@bgen(jjtree) XPath */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTXPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisNamespace:
      case AxisAncestorOrSelf:
      case ElementType:
      case AttributeType:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Root:
      case RootDescendants:
      case UnaryMinus:
      case UnaryPlus:
      case Lpar:
      case At:
      case Some:
      case Every:
      case ForVariable:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case IfLpar:
      case Dot:
      case DotDot:
      case VariableIndicator:
      case QName:
      case IDLpar:
      case KeyLpar:
      case QNameLpar:
        Expr();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Expr() throws ParseException {
 /*@bgen(jjtree) Expr */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ExprSingle();
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        jj_consume_token(Comma);
        ExprSingle();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Pattern() throws ParseException {
 /*@bgen(jjtree) Pattern */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      PathPattern();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Union:
      case Vbar:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Union:
          jj_consume_token(Union);
          break;
        case Vbar:
          jj_consume_token(Vbar);
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Pattern();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void PathPattern() throws ParseException {
 /*@bgen(jjtree) PathPattern */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPATHPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Root:
        jj_consume_token(Root);
            SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTROOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
        try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
        } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AxisChild:
        case AxisAttribute:
        case ElementType:
        case AttributeType:
        case Star:
        case NCNameColonStar:
        case StarColonNCName:
        case At:
        case DocumentLpar:
        case DocumentLparForKindTest:
        case NodeLpar:
        case CommentLpar:
        case TextLpar:
        case ProcessingInstructionLpar:
        case ElementTypeForKindTest:
        case ElementTypeForDocumentTest:
        case AttributeTypeForKindTest:
        case ProcessingInstructionLparForKindTest:
        case TextLparForKindTest:
        case CommentLparForKindTest:
        case NodeLparForKindTest:
        case QName:
          RelativePathPattern();
          break;
        default:
          jj_la1[4] = jj_gen;
          ;
        }
        break;
      case RootDescendants:
        jj_consume_token(RootDescendants);
                                                                                                    SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTROOTDESCENDANTS);
                                                                                                    boolean jjtc002 = true;
                                                                                                    jjtree.openNodeScope(jjtn002);
        try {
                                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                                    jjtc002 = false;
                                                                                       jjtn002.processToken(token);
        } finally {
                                                                                                    if (jjtc002) {
                                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                                    }
        }
        RelativePathPattern();
        break;
      case IDLpar:
      case KeyLpar:
        IdKeyPattern();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Slash:
        case SlashSlash:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Slash:
            jj_consume_token(Slash);
            break;
          case SlashSlash:
            jj_consume_token(SlashSlash);
                                                                                                                                                                                                                           SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSLASHSLASH);
                                                                                                                                                                                                                           boolean jjtc003 = true;
                                                                                                                                                                                                                           jjtree.openNodeScope(jjtn003);
            try {
                                                                                                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                           jjtc003 = false;
                                                                                                                                                                                       jjtn003.processToken(token);
            } finally {
                                                                                                                                                                                                                           if (jjtc003) {
                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                                                           }
            }
            break;
          default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          RelativePathPattern();
          break;
        default:
          jj_la1[6] = jj_gen;
          ;
        }
        break;
      case AxisChild:
      case AxisAttribute:
      case ElementType:
      case AttributeType:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case At:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case QName:
        RelativePathPattern();
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void RelativePathPattern() throws ParseException {
    PatternStep();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Slash:
    case SlashSlash:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Slash:
        jj_consume_token(Slash);
        break;
      case SlashSlash:
        jj_consume_token(SlashSlash);
                                          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSLASHSLASH);
                                          boolean jjtc001 = true;
                                          jjtree.openNodeScope(jjtn001);
        try {
                                          jjtree.closeNodeScope(jjtn001,  true);
                                          jjtc001 = false;
                                         jjtn001.processToken(token);
        } finally {
                                          if (jjtc001) {
                                            jjtree.closeNodeScope(jjtn001,  true);
                                          }
        }
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      RelativePathPattern();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
  }

  final public void PatternStep() throws ParseException {
 /*@bgen(jjtree) PatternStep */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPATTERNSTEP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AxisChild:
      case AxisAttribute:
      case At:
        PatternAxis();
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      NodeTest();
      Predicates();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void PatternAxis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisChild:
      jj_consume_token(AxisChild);
                SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISCHILD);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
      try {
                jjtree.closeNodeScope(jjtn001,  true);
                jjtc001 = false;
               jjtn001.processToken(token);
      } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  true);
                }
      }
      break;
    case AxisAttribute:
      jj_consume_token(AxisAttribute);
                                                                                 SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISATTRIBUTE);
                                                                                 boolean jjtc002 = true;
                                                                                 jjtree.openNodeScope(jjtn002);
      try {
                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                 jjtc002 = false;
                                                               jjtn002.processToken(token);
      } finally {
                                                                                 if (jjtc002) {
                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                 }
      }
      break;
    case At:
      jj_consume_token(At);
                                                                                                                                           SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAT);
                                                                                                                                           boolean jjtc003 = true;
                                                                                                                                           jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                           jjtc003 = false;
                                                                                                    jjtn003.processToken(token);
      } finally {
                                                                                                                                           if (jjtc003) {
                                                                                                                                             jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                           }
      }
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void IdKeyPattern() throws ParseException {
 /*@bgen(jjtree) IdKeyPattern */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIDKEYPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDLpar:
        jj_consume_token(IDLpar);
              SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIDLPAR);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
        try {
              jjtree.closeNodeScope(jjtn001,  true);
              jjtc001 = false;
             jjtn001.processToken(token);
        } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  true);
              }
        }
        IdKeyValue();
        jj_consume_token(Rpar);
        break;
      case KeyLpar:
        jj_consume_token(KeyLpar);
                                                                                            SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTKEYLPAR);
                                                                                            boolean jjtc002 = true;
                                                                                            jjtree.openNodeScope(jjtn002);
        try {
                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                            jjtc002 = false;
                                                                             jjtn002.processToken(token);
        } finally {
                                                                                            if (jjtc002) {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                            }
        }
        jj_consume_token(StringLiteral);
                                                                                                                                                         SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTRINGLITERAL);
                                                                                                                                                         boolean jjtc003 = true;
                                                                                                                                                         jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                         jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                         jjtc003 = false;
                                                                                                                           jjtn003.processToken(token);
        } finally {
                                                                                                                                                         if (jjtc003) {
                                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                         }
        }
        jj_consume_token(Comma);
        IdKeyValue();
        jj_consume_token(Rpar);
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void IdKeyValue() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case StringLiteral:
      jj_consume_token(StringLiteral);
                    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTRINGLITERAL);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
      try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
      } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
      }
      break;
    case VariableIndicator:
      jj_consume_token(VariableIndicator);
      jj_consume_token(VarName);
                                                                                                        SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVARNAME);
                                                                                                        boolean jjtc002 = true;
                                                                                                        jjtree.openNodeScope(jjtn002);
      try {
                                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                                        jjtc002 = false;
                                                                                  jjtn002.processToken(token);
      } finally {
                                                                                                        if (jjtc002) {
                                                                                                          jjtree.closeNodeScope(jjtn002,  true);
                                                                                                        }
      }
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ExprSingle() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ForVariable:
      ForExpr();
      break;
    case Some:
    case Every:
      QuantifiedExpr();
      break;
    case IfLpar:
      IfExpr();
      break;
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
    case StringLiteral:
    case AxisChild:
    case AxisDescendant:
    case AxisParent:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisAncestor:
    case AxisFollowingSibling:
    case AxisPrecedingSibling:
    case AxisFollowing:
    case AxisPreceding:
    case AxisNamespace:
    case AxisAncestorOrSelf:
    case ElementType:
    case AttributeType:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case Root:
    case RootDescendants:
    case UnaryMinus:
    case UnaryPlus:
    case Lpar:
    case At:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case Dot:
    case DotDot:
    case VariableIndicator:
    case QName:
    case IDLpar:
    case KeyLpar:
    case QNameLpar:
      OrExpr();
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ForExpr() throws ParseException {
 /*@bgen(jjtree) ForExpr */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTFOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      SimpleForClause();
      jj_consume_token(Return);
                               SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTRETURN);
                               boolean jjtc001 = true;
                               jjtree.openNodeScope(jjtn001);
      try {
                               jjtree.closeNodeScope(jjtn001,  true);
                               jjtc001 = false;
                              jjtn001.processToken(token);
      } finally {
                               if (jjtc001) {
                                 jjtree.closeNodeScope(jjtn001,  true);
                               }
      }
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SimpleForClause() throws ParseException {
    jj_consume_token(ForVariable);
    jj_consume_token(VarName);
                           SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVARNAME);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
    try {
                           jjtree.closeNodeScope(jjtn001,  true);
                           jjtc001 = false;
                          jjtn001.processToken(token);
    } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001,  true);
                           }
    }
    jj_consume_token(In);
                                                                             SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIN);
                                                                             boolean jjtc002 = true;
                                                                             jjtree.openNodeScope(jjtn002);
    try {
                                                                             jjtree.closeNodeScope(jjtn002,  true);
                                                                             jjtc002 = false;
                                                             jjtn002.processToken(token);
    } finally {
                                                                             if (jjtc002) {
                                                                               jjtree.closeNodeScope(jjtn002,  true);
                                                                             }
    }
    ExprSingle();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Comma:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_2;
      }
      jj_consume_token(Comma);
      jj_consume_token(VariableIndicator);
      jj_consume_token(VarName);
                                                                                                                                                                          SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVARNAME);
                                                                                                                                                                          boolean jjtc003 = true;
                                                                                                                                                                          jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                          jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                          jjtc003 = false;
                                                                                                                                                jjtn003.processToken(token);
      } finally {
                                                                                                                                                                          if (jjtc003) {
                                                                                                                                                                            jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                          }
      }
      jj_consume_token(In);
                                                                                                                                                                                                                             SimpleNode jjtn004 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIN);
                                                                                                                                                                                                                             boolean jjtc004 = true;
                                                                                                                                                                                                                             jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                             jjtc004 = false;
                                                                                                                                                                                    jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                             if (jjtc004) {
                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                             }
      }
      ExprSingle();
    }
  }

  final public void QuantifiedExpr() throws ParseException {
 /*@bgen(jjtree) QuantifiedExpr */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTQUANTIFIEDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Some:
        jj_consume_token(Some);
            SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSOME);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
        try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
        } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
        }
        break;
      case Every:
        jj_consume_token(Every);
                                                                SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEVERY);
                                                                boolean jjtc002 = true;
                                                                jjtree.openNodeScope(jjtn002);
        try {
                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                jjtc002 = false;
                                                   jjtn002.processToken(token);
        } finally {
                                                                if (jjtc002) {
                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                }
        }
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(VarName);
                                                                                                                      SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVARNAME);
                                                                                                                      boolean jjtc003 = true;
                                                                                                                      jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                      jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                      jjtc003 = false;
                                                                                            jjtn003.processToken(token);
      } finally {
                                                                                                                      if (jjtc003) {
                                                                                                                        jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                      }
      }
      jj_consume_token(In);
                                                                                                                                                                        SimpleNode jjtn004 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIN);
                                                                                                                                                                        boolean jjtc004 = true;
                                                                                                                                                                        jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                        jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                        jjtc004 = false;
                                                                                                                               jjtn004.processToken(token);
      } finally {
                                                                                                                                                                        if (jjtc004) {
                                                                                                                                                                          jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                        }
      }
      ExprSingle();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Comma:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_3;
        }
        jj_consume_token(Comma);
        jj_consume_token(VariableIndicator);
        jj_consume_token(VarName);
                                                                                                                                                                                                                                                                     SimpleNode jjtn005 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVARNAME);
                                                                                                                                                                                                                                                                     boolean jjtc005 = true;
                                                                                                                                                                                                                                                                     jjtree.openNodeScope(jjtn005);
        try {
                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                     jjtc005 = false;
                                                                                                                                                                                                                  jjtn005.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                     if (jjtc005) {
                                                                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                     }
        }
        jj_consume_token(In);
                                                                                                                                                                                                                                                                                                                        SimpleNode jjtn006 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIN);
                                                                                                                                                                                                                                                                                                                        boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                        jjtree.openNodeScope(jjtn006);
        try {
                                                                                                                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                        jjtc006 = false;
                                                                                                                                                                                                                                                      jjtn006.processToken(token);
        } finally {
                                                                                                                                                                                                                                                                                                                        if (jjtc006) {
                                                                                                                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                        }
        }
        ExprSingle();
      }
      jj_consume_token(Satisfies);
                                                                                                                                                                                                                                                                                                                                                                                           SimpleNode jjtn007 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSATISFIES);
                                                                                                                                                                                                                                                                                                                                                                                           boolean jjtc007 = true;
                                                                                                                                                                                                                                                                                                                                                                                           jjtree.openNodeScope(jjtn007);
      try {
                                                                                                                                                                                                                                                                                                                                                                                           jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                           jjtc007 = false;
                                                                                                                                                                                                                                                                                                               jjtn007.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                           if (jjtc007) {
                                                                                                                                                                                                                                                                                                                                                                                             jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                           }
      }
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void IfExpr() throws ParseException {
 /*@bgen(jjtree) IfExpr */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IfLpar);
      Expr();
      jj_consume_token(Rpar);
      jj_consume_token(Then);
      ExprSingle();
      jj_consume_token(Else);
      ExprSingle();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void OperatorExpr() throws ParseException {
    OrExpr();
  }

  final public void OrExpr() throws ParseException {
 /*@bgen(jjtree) #OrExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AndExpr();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Or:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_4;
        }
        jj_consume_token(Or);
          binaryTokenStack.push(token);
        AndExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTOREXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void AndExpr() throws ParseException {
 /*@bgen(jjtree) #AndExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTANDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      InstanceofExpr();
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case And:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_5;
        }
        jj_consume_token(And);
          binaryTokenStack.push(token);
        InstanceofExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTANDEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void InstanceofExpr() throws ParseException {
 /*@bgen(jjtree) #InstanceofExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTINSTANCEOFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      TreatExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Instanceof:
        jj_consume_token(Instanceof);
        SequenceType();
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void TreatExpr() throws ParseException {
 /*@bgen(jjtree) #TreatExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTTREATEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      CastableExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TreatAs:
        jj_consume_token(TreatAs);
        SequenceType();
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void CastableExpr() throws ParseException {
 /*@bgen(jjtree) #CastableExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTCASTABLEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      CastExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Castable:
        jj_consume_token(Castable);
        SingleType();
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void CastExpr() throws ParseException {
 /*@bgen(jjtree) #CastExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTCASTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ComparisonExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CastAs:
        jj_consume_token(CastAs);
        SingleType();
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void ComparisonExpr() throws ParseException {
 /*@bgen(jjtree) #ComparisonExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTCOMPARISONEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      RangeExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Equals:
      case Is:
      case NotEquals:
      case IsNot:
      case LtEquals:
      case LtLt:
      case GtEquals:
      case GtGt:
      case FortranEq:
      case FortranNe:
      case FortranGt:
      case FortranGe:
      case FortranLt:
      case FortranLe:
      case Lt:
      case Gt:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FortranEq:
        case FortranNe:
        case FortranGt:
        case FortranGe:
        case FortranLt:
        case FortranLe:
          ValueComp();
          break;
        case Equals:
        case NotEquals:
        case LtEquals:
        case GtEquals:
        case Lt:
        case Gt:
          GeneralComp();
          break;
        case Is:
        case IsNot:
          NodeComp();
          break;
        case LtLt:
        case GtGt:
          OrderComp();
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        RangeExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTCOMPARISONEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void RangeExpr() throws ParseException {
 /*@bgen(jjtree) #RangeExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTRANGEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AdditiveExpr();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case To:
        jj_consume_token(To);
          binaryTokenStack.push(token);
        AdditiveExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTRANGEEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void AdditiveExpr() throws ParseException {
 /*@bgen(jjtree) #AdditiveExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTADDITIVEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      MultiplicativeExpr();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Minus:
        case Plus:
          ;
          break;
        default:
          jj_la1[27] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Plus:
          jj_consume_token(Plus);
          binaryTokenStack.push(token);
          break;
        case Minus:
          jj_consume_token(Minus);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[28] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        MultiplicativeExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTADDITIVEEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void MultiplicativeExpr() throws ParseException {
 /*@bgen(jjtree) #MultiplicativeExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTMULTIPLICATIVEEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      UnaryExpr();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Div:
        case Idiv:
        case Mod:
        case Multiply:
          ;
          break;
        default:
          jj_la1[29] = jj_gen;
          break label_7;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Multiply:
          jj_consume_token(Multiply);
          binaryTokenStack.push(token);
          break;
        case Div:
          jj_consume_token(Div);
          binaryTokenStack.push(token);
          break;
        case Idiv:
          jj_consume_token(Idiv);
          binaryTokenStack.push(token);
          break;
        case Mod:
          jj_consume_token(Mod);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        UnaryExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTMULTIPLICATIVEEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void UnaryExpr() throws ParseException {
 /*@bgen(jjtree) #UnaryExpr( keepUnary) */
 SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTUNARYEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean keepUnary=false;
    try {
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UnaryMinus:
        case UnaryPlus:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_8;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UnaryMinus:
          jj_consume_token(UnaryMinus);
                 SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTUNARYMINUS);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
          try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                keepUnary=true;jjtn001.processToken(token);
          } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
          }
          break;
        case UnaryPlus:
          jj_consume_token(UnaryPlus);
                                                                                              SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTUNARYPLUS);
                                                                                              boolean jjtc002 = true;
                                                                                              jjtree.openNodeScope(jjtn002);
          try {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                              jjtc002 = false;
                                                                           keepUnary=true;jjtn002.processToken(token);
          } finally {
                                                                                              if (jjtc002) {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                              }
          }
          break;
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      UnionExpr();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000,  keepUnary);
    }
    }
  }

  final public void UnionExpr() throws ParseException {
 /*@bgen(jjtree) #UnionExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTUNIONEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      IntersectExceptExpr();
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Union:
        case Vbar:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Union:
          jj_consume_token(Union);
          binaryTokenStack.push(token);
          break;
        case Vbar:
          jj_consume_token(Vbar);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[34] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        IntersectExceptExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTUNIONEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void IntersectExceptExpr() throws ParseException {
 /*@bgen(jjtree) #IntersectExceptExpr(> 1) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTINTERSECTEXCEPTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      ValueExpr();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Intersect:
        case Except:
          ;
          break;
        default:
          jj_la1[35] = jj_gen;
          break label_10;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Intersect:
          jj_consume_token(Intersect);
          binaryTokenStack.push(token);
          break;
        case Except:
          jj_consume_token(Except);
          binaryTokenStack.push(token);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        ValueExpr();
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTINTERSECTEXCEPTEXPR);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  2);
                  jjtc001 = false;
         try
         {
                       jjtn001.processToken((Token)binaryTokenStack.pop());
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           {if (true) throw e;}
         }
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
    }
    }
  }

  final public void ValueExpr() throws ParseException {
    PathExpr();
  }

  final public void PathExpr() throws ParseException {
 /*@bgen(jjtree) #PathExpr(> 0) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPATHEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Root:
        jj_consume_token(Root);
            SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTROOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
        try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
        } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IntegerLiteral:
        case DecimalLiteral:
        case DoubleLiteral:
        case StringLiteral:
        case AxisChild:
        case AxisDescendant:
        case AxisParent:
        case AxisAttribute:
        case AxisSelf:
        case AxisDescendantOrSelf:
        case AxisAncestor:
        case AxisFollowingSibling:
        case AxisPrecedingSibling:
        case AxisFollowing:
        case AxisPreceding:
        case AxisNamespace:
        case AxisAncestorOrSelf:
        case ElementType:
        case AttributeType:
        case Star:
        case NCNameColonStar:
        case StarColonNCName:
        case Lpar:
        case At:
        case DocumentLpar:
        case DocumentLparForKindTest:
        case NodeLpar:
        case CommentLpar:
        case TextLpar:
        case ProcessingInstructionLpar:
        case ElementTypeForKindTest:
        case ElementTypeForDocumentTest:
        case AttributeTypeForKindTest:
        case ProcessingInstructionLparForKindTest:
        case TextLparForKindTest:
        case CommentLparForKindTest:
        case NodeLparForKindTest:
        case Dot:
        case DotDot:
        case VariableIndicator:
        case QName:
        case IDLpar:
        case KeyLpar:
        case QNameLpar:
          RelativePathExpr();
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
        break;
      case RootDescendants:
        jj_consume_token(RootDescendants);
                                                                                                 SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTROOTDESCENDANTS);
                                                                                                 boolean jjtc002 = true;
                                                                                                 jjtree.openNodeScope(jjtn002);
        try {
                                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                                 jjtc002 = false;
                                                                                    jjtn002.processToken(token);
        } finally {
                                                                                                 if (jjtc002) {
                                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                                 }
        }
        RelativePathExpr();
        break;
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisNamespace:
      case AxisAncestorOrSelf:
      case ElementType:
      case AttributeType:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Lpar:
      case At:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case Dot:
      case DotDot:
      case VariableIndicator:
      case QName:
      case IDLpar:
      case KeyLpar:
      case QNameLpar:
        RelativePathExpr();
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 0);
    }
    }
  }

  final public void RelativePathExpr() throws ParseException {
    StepExpr();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Slash:
      case SlashSlash:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Slash:
        jj_consume_token(Slash);
        break;
      case SlashSlash:
        jj_consume_token(SlashSlash);
                                       SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSLASHSLASH);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
        try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
        } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
        }
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      StepExpr();
    }
  }

  final public void StepExpr() throws ParseException {
 /*@bgen(jjtree) #StepExpr(> 1 || isStep) */
 SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTEPEXPR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);boolean savedIsStep = isStep; isStep=false;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisNamespace:
      case AxisAncestorOrSelf:
      case ElementType:
      case AttributeType:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case At:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case DotDot:
      case QName:
    isStep=true;
        AxisStep();
                             jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
                             jjtc000 = false;
                            isStep = savedIsStep;
        break;
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case Lpar:
      case Dot:
      case VariableIndicator:
      case IDLpar:
      case KeyLpar:
      case QNameLpar:
        FilterStep();
                                                                   jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
                                                                   jjtc000 = false;
                                                                  isStep = savedIsStep;
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1 || isStep);
    }
    }
  }

  final public void AxisStep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisChild:
    case AxisDescendant:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisFollowingSibling:
    case AxisFollowing:
    case AxisNamespace:
    case ElementType:
    case AttributeType:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case At:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case QName:
      ForwardStep();
      break;
    case AxisParent:
    case AxisAncestor:
    case AxisPrecedingSibling:
    case AxisPreceding:
    case AxisAncestorOrSelf:
    case DotDot:
      ReverseStep();
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    Predicates();
  }

  final public void FilterStep() throws ParseException {
    PrimaryExpr();
    Predicates();
  }

  final public void ContextItemExpr() throws ParseException {
    jj_consume_token(Dot);
         SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDOT);
         boolean jjtc001 = true;
         jjtree.openNodeScope(jjtn001);
    try {
         jjtree.closeNodeScope(jjtn001,  true);
         jjtc001 = false;
        jjtn001.processToken(token);
    } finally {
         if (jjtc001) {
           jjtree.closeNodeScope(jjtn001,  true);
         }
    }
  }

  final public void PrimaryExpr() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
    case StringLiteral:
      Literal();
      break;
    case IDLpar:
    case KeyLpar:
    case QNameLpar:
      FunctionCall();
      break;
    case Dot:
                                 isStep=true;
      ContextItemExpr();
      break;
    case VariableIndicator:
      jj_consume_token(VariableIndicator);
      jj_consume_token(VarName);
                                                                                                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTVARNAME);
                                                                                                  boolean jjtc001 = true;
                                                                                                  jjtree.openNodeScope(jjtn001);
      try {
                                                                                                  jjtree.closeNodeScope(jjtn001,  true);
                                                                                                  jjtc001 = false;
                                                                                                 jjtn001.processToken(token);
      } finally {
                                                                                                  if (jjtc001) {
                                                                                                    jjtree.closeNodeScope(jjtn001,  true);
                                                                                                  }
      }
      break;
    case Lpar:
      ParenthesizedExpr();
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Predicates() throws ParseException {
 /*@bgen(jjtree) #Predicates(> 0) */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPREDICATES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case Lbrack:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_12;
        }
        jj_consume_token(Lbrack);
        Expr();
        jj_consume_token(Rbrack);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 0);
    }
    }
  }

  final public void GeneralComp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Equals:
      jj_consume_token(Equals);
          binaryTokenStack.push(token);
      break;
    case NotEquals:
      jj_consume_token(NotEquals);
          binaryTokenStack.push(token);
      break;
    case Lt:
      jj_consume_token(Lt);
          binaryTokenStack.push(token);
      break;
    case LtEquals:
      jj_consume_token(LtEquals);
          binaryTokenStack.push(token);
      break;
    case Gt:
      jj_consume_token(Gt);
          binaryTokenStack.push(token);
      break;
    case GtEquals:
      jj_consume_token(GtEquals);
          binaryTokenStack.push(token);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ValueComp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FortranEq:
      jj_consume_token(FortranEq);
          binaryTokenStack.push(token);
      break;
    case FortranNe:
      jj_consume_token(FortranNe);
          binaryTokenStack.push(token);
      break;
    case FortranLt:
      jj_consume_token(FortranLt);
          binaryTokenStack.push(token);
      break;
    case FortranLe:
      jj_consume_token(FortranLe);
          binaryTokenStack.push(token);
      break;
    case FortranGt:
      jj_consume_token(FortranGt);
          binaryTokenStack.push(token);
      break;
    case FortranGe:
      jj_consume_token(FortranGe);
          binaryTokenStack.push(token);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NodeComp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Is:
      jj_consume_token(Is);
          binaryTokenStack.push(token);
      break;
    case IsNot:
      jj_consume_token(IsNot);
          binaryTokenStack.push(token);
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void OrderComp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LtLt:
      jj_consume_token(LtLt);
          binaryTokenStack.push(token);
      break;
    case GtGt:
      jj_consume_token(GtGt);
          binaryTokenStack.push(token);
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ForwardStep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisChild:
    case AxisDescendant:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisFollowingSibling:
    case AxisFollowing:
    case AxisNamespace:
      ForwardAxis();
      NodeTest();
      break;
    case ElementType:
    case AttributeType:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case At:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case QName:
      AbbrevForwardStep();
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ReverseStep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisParent:
    case AxisAncestor:
    case AxisPrecedingSibling:
    case AxisPreceding:
    case AxisAncestorOrSelf:
      ReverseAxis();
      NodeTest();
      break;
    case DotDot:
      AbbrevReverseStep();
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void AbbrevForwardStep() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case At:
      jj_consume_token(At);
         SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAT);
         boolean jjtc001 = true;
         jjtree.openNodeScope(jjtn001);
      try {
         jjtree.closeNodeScope(jjtn001,  true);
         jjtc001 = false;
        jjtn001.processToken(token);
      } finally {
         if (jjtc001) {
           jjtree.closeNodeScope(jjtn001,  true);
         }
      }
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    NodeTest();
  }

  final public void AbbrevReverseStep() throws ParseException {
    jj_consume_token(DotDot);
            SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDOTDOT);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
    try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
    } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
    }
  }

  final public void ForwardAxis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisChild:
      jj_consume_token(AxisChild);
                SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISCHILD);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
      try {
                jjtree.closeNodeScope(jjtn001,  true);
                jjtc001 = false;
               jjtn001.processToken(token);
      } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  true);
                }
      }
      break;
    case AxisDescendant:
      jj_consume_token(AxisDescendant);
                                                                                  SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISDESCENDANT);
                                                                                  boolean jjtc002 = true;
                                                                                  jjtree.openNodeScope(jjtn002);
      try {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                  jjtc002 = false;
                                                                jjtn002.processToken(token);
      } finally {
                                                                                  if (jjtc002) {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                  }
      }
      break;
    case AxisAttribute:
      jj_consume_token(AxisAttribute);
                                                                                                                                                        SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISATTRIBUTE);
                                                                                                                                                        boolean jjtc003 = true;
                                                                                                                                                        jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                        jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                        jjtc003 = false;
                                                                                                                jjtn003.processToken(token);
      } finally {
                                                                                                                                                        if (jjtc003) {
                                                                                                                                                          jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                        }
      }
      break;
    case AxisSelf:
      jj_consume_token(AxisSelf);
                                                                                                                                                                                                                        SimpleNode jjtn004 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISSELF);
                                                                                                                                                                                                                        boolean jjtc004 = true;
                                                                                                                                                                                                                        jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                        jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                        jjtc004 = false;
                                                                                                                                                           jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                        if (jjtc004) {
                                                                                                                                                                                                                          jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                        }
      }
      break;
    case AxisDescendantOrSelf:
      jj_consume_token(AxisDescendantOrSelf);
                                                                                                                                                                                                                                                                                               SimpleNode jjtn005 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISDESCENDANTORSELF);
                                                                                                                                                                                                                                                                                               boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                               jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                               jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                               jjtc005 = false;
                                                                                                                                                                                                                  jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                               if (jjtc005) {
                                                                                                                                                                                                                                                                                                 jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                               }
      }
      break;
    case AxisFollowingSibling:
      jj_consume_token(AxisFollowingSibling);
                                                                                                                                                                                                                                                                                                                                                                                  SimpleNode jjtn006 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISFOLLOWINGSIBLING);
                                                                                                                                                                                                                                                                                                                                                                                  boolean jjtc006 = true;
                                                                                                                                                                                                                                                                                                                                                                                  jjtree.openNodeScope(jjtn006);
      try {
                                                                                                                                                                                                                                                                                                                                                                                  jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                  jjtc006 = false;
                                                                                                                                                                                                                                                                         jjtn006.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                  if (jjtc006) {
                                                                                                                                                                                                                                                                                                                                                                                    jjtree.closeNodeScope(jjtn006,  true);
                                                                                                                                                                                                                                                                                                                                                                                  }
      }
      break;
    case AxisFollowing:
      jj_consume_token(AxisFollowing);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              SimpleNode jjtn007 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISFOLLOWING);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              boolean jjtc007 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                                              jjtree.openNodeScope(jjtn007);
      try {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              jjtc007 = false;
                                                                                                                                                                                                                                                                                                                         jjtn007.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                                              if (jjtc007) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                jjtree.closeNodeScope(jjtn007,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                              }
      }
      break;
    case AxisNamespace:
      jj_consume_token(AxisNamespace);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   SimpleNode jjtn008 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISNAMESPACE);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   boolean jjtc008 = true;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   jjtree.openNodeScope(jjtn008);
      try {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn008,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   jjtc008 = false;
                                                                                                                                                                                                                                                                                                                                                                         jjtn008.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   if (jjtc008) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn008,  true);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   }
      }
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ReverseAxis() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AxisParent:
      jj_consume_token(AxisParent);
                 SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISPARENT);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
      try {
                 jjtree.closeNodeScope(jjtn001,  true);
                 jjtc001 = false;
                jjtn001.processToken(token);
      } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  true);
                 }
      }
      break;
    case AxisAncestor:
      jj_consume_token(AxisAncestor);
                                                                                  SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISANCESTOR);
                                                                                  boolean jjtc002 = true;
                                                                                  jjtree.openNodeScope(jjtn002);
      try {
                                                                                  jjtree.closeNodeScope(jjtn002,  true);
                                                                                  jjtc002 = false;
                                                               jjtn002.processToken(token);
      } finally {
                                                                                  if (jjtc002) {
                                                                                    jjtree.closeNodeScope(jjtn002,  true);
                                                                                  }
      }
      break;
    case AxisPrecedingSibling:
      jj_consume_token(AxisPrecedingSibling);
                                                                                                                                                             SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISPRECEDINGSIBLING);
                                                                                                                                                             boolean jjtc003 = true;
                                                                                                                                                             jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                             jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                             jjtc003 = false;
                                                                                                                      jjtn003.processToken(token);
      } finally {
                                                                                                                                                             if (jjtc003) {
                                                                                                                                                               jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                             }
      }
      break;
    case AxisPreceding:
      jj_consume_token(AxisPreceding);
                                                                                                                                                                                                                                         SimpleNode jjtn004 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISPRECEDING);
                                                                                                                                                                                                                                         boolean jjtc004 = true;
                                                                                                                                                                                                                                         jjtree.openNodeScope(jjtn004);
      try {
                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                         jjtc004 = false;
                                                                                                                                                                      jjtn004.processToken(token);
      } finally {
                                                                                                                                                                                                                                         if (jjtc004) {
                                                                                                                                                                                                                                           jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                         }
      }
      break;
    case AxisAncestorOrSelf:
      jj_consume_token(AxisAncestorOrSelf);
                                                                                                                                                                                                                                                                                                                   SimpleNode jjtn005 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAXISANCESTORORSELF);
                                                                                                                                                                                                                                                                                                                   boolean jjtc005 = true;
                                                                                                                                                                                                                                                                                                                   jjtree.openNodeScope(jjtn005);
      try {
                                                                                                                                                                                                                                                                                                                   jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                   jjtc005 = false;
                                                                                                                                                                                                                           jjtn005.processToken(token);
      } finally {
                                                                                                                                                                                                                                                                                                                   if (jjtc005) {
                                                                                                                                                                                                                                                                                                                     jjtree.closeNodeScope(jjtn005,  true);
                                                                                                                                                                                                                                                                                                                   }
      }
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NodeTest() throws ParseException {
 /*@bgen(jjtree) NodeTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTNODETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ElementType:
      case AttributeType:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
        KindTest();
        break;
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case QName:
        NameTest();
        break;
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void NameTest() throws ParseException {
 /*@bgen(jjtree) NameTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTNAMETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QName:
        jj_consume_token(QName);
            SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTQNAME);
            boolean jjtc001 = true;
            jjtree.openNodeScope(jjtn001);
        try {
            jjtree.closeNodeScope(jjtn001,  true);
            jjtc001 = false;
           jjtn001.processToken(token);
        } finally {
            if (jjtc001) {
              jjtree.closeNodeScope(jjtn001,  true);
            }
        }
        break;
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
        Wildcard();
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Wildcard() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case Star:
      jj_consume_token(Star);
           SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTAR);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
      try {
           jjtree.closeNodeScope(jjtn001,  true);
           jjtc001 = false;
          jjtn001.processToken(token);
      } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  true);
           }
      }
      break;
    case NCNameColonStar:
      jj_consume_token(NCNameColonStar);
                                                                         SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTNCNAMECOLONSTAR);
                                                                         boolean jjtc002 = true;
                                                                         jjtree.openNodeScope(jjtn002);
      try {
                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                         jjtc002 = false;
                                                            jjtn002.processToken(token);
      } finally {
                                                                         if (jjtc002) {
                                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                                         }
      }
      break;
    case StarColonNCName:
      jj_consume_token(StarColonNCName);
                                                                                                                                                  SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTARCOLONNCNAME);
                                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                                  jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                  jjtc003 = false;
                                                                                                              jjtn003.processToken(token);
      } finally {
                                                                                                                                                  if (jjtc003) {
                                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                  }
      }
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Literal() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
      NumericLiteral();
      break;
    case StringLiteral:
      jj_consume_token(StringLiteral);
                                       SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTRINGLITERAL);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
      try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
      } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
      }
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NumericLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
      jj_consume_token(IntegerLiteral);
                     SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTINTEGERLITERAL);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
      try {
                     jjtree.closeNodeScope(jjtn001,  true);
                     jjtc001 = false;
                    jjtn001.processToken(token);
      } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001,  true);
                     }
      }
      break;
    case DecimalLiteral:
      jj_consume_token(DecimalLiteral);
                                                                                            SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDECIMALLITERAL);
                                                                                            boolean jjtc002 = true;
                                                                                            jjtree.openNodeScope(jjtn002);
      try {
                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                            jjtc002 = false;
                                                                     jjtn002.processToken(token);
      } finally {
                                                                                            if (jjtc002) {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                            }
      }
      break;
    case DoubleLiteral:
      jj_consume_token(DoubleLiteral);
                                                                                                                                                                  SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDOUBLELITERAL);
                                                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                                                  jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  jjtc003 = false;
                                                                                                                     jjtn003.processToken(token);
      } finally {
                                                                                                                                                                  if (jjtc003) {
                                                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                  }
      }
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ParenthesizedExpr() throws ParseException {
    jj_consume_token(Lpar);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IntegerLiteral:
    case DecimalLiteral:
    case DoubleLiteral:
    case StringLiteral:
    case AxisChild:
    case AxisDescendant:
    case AxisParent:
    case AxisAttribute:
    case AxisSelf:
    case AxisDescendantOrSelf:
    case AxisAncestor:
    case AxisFollowingSibling:
    case AxisPrecedingSibling:
    case AxisFollowing:
    case AxisPreceding:
    case AxisNamespace:
    case AxisAncestorOrSelf:
    case ElementType:
    case AttributeType:
    case Star:
    case NCNameColonStar:
    case StarColonNCName:
    case Root:
    case RootDescendants:
    case UnaryMinus:
    case UnaryPlus:
    case Lpar:
    case At:
    case Some:
    case Every:
    case ForVariable:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
    case IfLpar:
    case Dot:
    case DotDot:
    case VariableIndicator:
    case QName:
    case IDLpar:
    case KeyLpar:
    case QNameLpar:
      Expr();
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    jj_consume_token(Rpar);
  }

  final public void FunctionCall() throws ParseException {
 /*@bgen(jjtree) FunctionCall */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTFUNCTIONCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QNameLpar:
        jj_consume_token(QNameLpar);
                SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTQNAMELPAR);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
        try {
                jjtree.closeNodeScope(jjtn001,  true);
                jjtc001 = false;
               jjtn001.processToken(token);
        } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  true);
                }
        }
        break;
      case IDLpar:
        jj_consume_token(IDLpar);
                                                                          SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTIDLPAR);
                                                                          boolean jjtc002 = true;
                                                                          jjtree.openNodeScope(jjtn002);
        try {
                                                                          jjtree.closeNodeScope(jjtn002,  true);
                                                                          jjtc002 = false;
                                                        jjtn002.processToken(token);
        } finally {
                                                                          if (jjtc002) {
                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                          }
        }
        break;
      case KeyLpar:
        jj_consume_token(KeyLpar);
                                                                                                                                  SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTKEYLPAR);
                                                                                                                                  boolean jjtc003 = true;
                                                                                                                                  jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                  jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                  jjtc003 = false;
                                                                                                  jjtn003.processToken(token);
        } finally {
                                                                                                                                  if (jjtc003) {
                                                                                                                                    jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                  }
        }
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IntegerLiteral:
      case DecimalLiteral:
      case DoubleLiteral:
      case StringLiteral:
      case AxisChild:
      case AxisDescendant:
      case AxisParent:
      case AxisAttribute:
      case AxisSelf:
      case AxisDescendantOrSelf:
      case AxisAncestor:
      case AxisFollowingSibling:
      case AxisPrecedingSibling:
      case AxisFollowing:
      case AxisPreceding:
      case AxisNamespace:
      case AxisAncestorOrSelf:
      case ElementType:
      case AttributeType:
      case Star:
      case NCNameColonStar:
      case StarColonNCName:
      case Root:
      case RootDescendants:
      case UnaryMinus:
      case UnaryPlus:
      case Lpar:
      case At:
      case Some:
      case Every:
      case ForVariable:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case IfLpar:
      case Dot:
      case DotDot:
      case VariableIndicator:
      case QName:
      case IDLpar:
      case KeyLpar:
      case QNameLpar:
        ExprSingle();
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case Comma:
            ;
            break;
          default:
            jj_la1[61] = jj_gen;
            break label_13;
          }
          jj_consume_token(Comma);
          ExprSingle();
        }
        break;
      default:
        jj_la1[62] = jj_gen;
        ;
      }
      jj_consume_token(Rpar);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SingleType() throws ParseException {
 /*@bgen(jjtree) SingleType */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSINGLETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      AtomicType();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OccurrenceZeroOrOne:
        jj_consume_token(OccurrenceZeroOrOne);
                                       SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTOCCURRENCEZEROORONE);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
        try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
        } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
        }
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SequenceType() throws ParseException {
 /*@bgen(jjtree) SequenceType */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSEQUENCETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case Item:
      case ElementType:
      case AttributeType:
      case DocumentLpar:
      case DocumentLparForKindTest:
      case NodeLpar:
      case CommentLpar:
      case TextLpar:
      case ProcessingInstructionLpar:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
      case AttributeTypeForKindTest:
      case ProcessingInstructionLparForKindTest:
      case TextLparForKindTest:
      case CommentLparForKindTest:
      case NodeLparForKindTest:
      case QNameForSequenceType:
        ItemType();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OccurrenceZeroOrOne:
        case OccurrenceZeroOrMore:
        case OccurrenceOneOrMore:
          OccurrenceIndicator();
          break;
        default:
          jj_la1[64] = jj_gen;
          ;
        }
        break;
      case Empty:
        jj_consume_token(Empty);
                                                   SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTEMPTY);
                                                   boolean jjtc001 = true;
                                                   jjtree.openNodeScope(jjtn001);
        try {
                                                   jjtree.closeNodeScope(jjtn001,  true);
                                                   jjtc001 = false;
                                                  jjtn001.processToken(token);
        } finally {
                                                   if (jjtc001) {
                                                     jjtree.closeNodeScope(jjtn001,  true);
                                                   }
        }
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void AtomicType() throws ParseException {
    jj_consume_token(QNameForSequenceType);
                          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTQNAMEFORSEQUENCETYPE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
    try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
    } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
    }
  }

  final public void ItemType() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case QNameForSequenceType:
      AtomicType();
      break;
    case ElementType:
    case AttributeType:
    case DocumentLpar:
    case DocumentLparForKindTest:
    case NodeLpar:
    case CommentLpar:
    case TextLpar:
    case ProcessingInstructionLpar:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
    case AttributeTypeForKindTest:
    case ProcessingInstructionLparForKindTest:
    case TextLparForKindTest:
    case CommentLparForKindTest:
    case NodeLparForKindTest:
      KindTest();
      break;
    case Item:
      jj_consume_token(Item);
                                       SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTITEM);
                                       boolean jjtc001 = true;
                                       jjtree.openNodeScope(jjtn001);
      try {
                                       jjtree.closeNodeScope(jjtn001,  true);
                                       jjtc001 = false;
                                      jjtn001.processToken(token);
      } finally {
                                       if (jjtc001) {
                                         jjtree.closeNodeScope(jjtn001,  true);
                                       }
      }
      break;
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void KindTest() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DocumentLpar:
    case DocumentLparForKindTest:
      DocumentTest();
      break;
    case ElementType:
    case ElementTypeForKindTest:
    case ElementTypeForDocumentTest:
      ElementTest();
      break;
    case AttributeType:
    case AttributeTypeForKindTest:
      AttributeTest();
      break;
    case ProcessingInstructionLpar:
    case ProcessingInstructionLparForKindTest:
      PITest();
      break;
    case CommentLpar:
    case CommentLparForKindTest:
      CommentTest();
      break;
    case TextLpar:
    case TextLparForKindTest:
      TextTest();
      break;
    case NodeLpar:
    case NodeLparForKindTest:
      AnyKindTest();
      break;
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ElementTest() throws ParseException {
 /*@bgen(jjtree) ElementTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTELEMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ElementType:
        jj_consume_token(ElementType);
                  SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTELEMENTTYPE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
        try {
                  jjtree.closeNodeScope(jjtn001,  true);
                  jjtc001 = false;
                 jjtn001.processToken(token);
        } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  true);
                  }
        }
        break;
      case ElementTypeForKindTest:
        jj_consume_token(ElementTypeForKindTest);
                                                                                              SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTELEMENTTYPEFORKINDTEST);
                                                                                              boolean jjtc002 = true;
                                                                                              jjtree.openNodeScope(jjtn002);
        try {
                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                              jjtc002 = false;
                                                                          jjtn002.processToken(token);
        } finally {
                                                                                              if (jjtc002) {
                                                                                                jjtree.closeNodeScope(jjtn002,  true);
                                                                                              }
        }
        break;
      case ElementTypeForDocumentTest:
        jj_consume_token(ElementTypeForDocumentTest);
                                                                                                                                                                                         SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTELEMENTTYPEFORDOCUMENTTEST);
                                                                                                                                                                                         boolean jjtc003 = true;
                                                                                                                                                                                         jjtree.openNodeScope(jjtn003);
        try {
                                                                                                                                                                                         jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                         jjtc003 = false;
                                                                                                                                       jjtn003.processToken(token);
        } finally {
                                                                                                                                                                                         if (jjtc003) {
                                                                                                                                                                                           jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                         }
        }
        break;
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SchemaGlobalContextSlash:
      case AnyName:
      case QNameForItemType:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SchemaGlobalContextSlash:
          SchemaContextPath();
          LocalName();
          break;
        case AnyName:
        case QNameForItemType:
          NodeName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CommaForKindTest:
            jj_consume_token(CommaForKindTest);
            TypeName();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case Nillable:
              jj_consume_token(Nillable);
                                                                                                                                                                                                                                                                                                                                                       SimpleNode jjtn004 = (SimpleNode)SimpleNode.jjtCreate(this, JJTNILLABLE);
                                                                                                                                                                                                                                                                                                                                                       boolean jjtc004 = true;
                                                                                                                                                                                                                                                                                                                                                       jjtree.openNodeScope(jjtn004);
              try {
                                                                                                                                                                                                                                                                                                                                                       jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                                                                                                       jjtc004 = false;
                                                                                                                                                                                                                                                                   jjtn004.processToken(token);
              } finally {
                                                                                                                                                                                                                                                                                                                                                       if (jjtc004) {
                                                                                                                                                                                                                                                                                                                                                         jjtree.closeNodeScope(jjtn004,  true);
                                                                                                                                                                                                                                                                                                                                                       }
              }
              break;
            default:
              jj_la1[69] = jj_gen;
              ;
            }
            break;
          default:
            jj_la1[70] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[71] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[72] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void AttributeTest() throws ParseException {
 /*@bgen(jjtree) AttributeTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTATTRIBUTETEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AttributeType:
        jj_consume_token(AttributeType);
                    SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTATTRIBUTETYPE);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
        try {
                    jjtree.closeNodeScope(jjtn001,  true);
                    jjtc001 = false;
                   jjtn001.processToken(token);
        } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  true);
                    }
        }
        break;
      case AttributeTypeForKindTest:
        jj_consume_token(AttributeTypeForKindTest);
        break;
      default:
        jj_la1[73] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SchemaGlobalContextSlash:
      case At:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SchemaGlobalContextSlash:
          SchemaContextPath();
          jj_consume_token(At);
                                                                                                                                 SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAT);
                                                                                                                                 boolean jjtc002 = true;
                                                                                                                                 jjtree.openNodeScope(jjtn002);
          try {
                                                                                                                                 jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                 jjtc002 = false;
                                                                                                           jjtn002.processToken(token);
          } finally {
                                                                                                                                 if (jjtc002) {
                                                                                                                                   jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                 }
          }
          LocalName();
          break;
        case At:
          jj_consume_token(At);
                                                                                                                                                                                              SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTAT);
                                                                                                                                                                                              boolean jjtc003 = true;
                                                                                                                                                                                              jjtree.openNodeScope(jjtn003);
          try {
                                                                                                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                              jjtc003 = false;
                                                                                                                                                              jjtn003.processToken(token);
          } finally {
                                                                                                                                                                                              if (jjtc003) {
                                                                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                              }
          }
          NodeName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CommaForKindTest:
            jj_consume_token(CommaForKindTest);
            TypeName();
            break;
          default:
            jj_la1[74] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[75] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void PITest() throws ParseException {
 /*@bgen(jjtree) PITest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTPITEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ProcessingInstructionLpar:
        jj_consume_token(ProcessingInstructionLpar);
        break;
      case ProcessingInstructionLparForKindTest:
        jj_consume_token(ProcessingInstructionLparForKindTest);
        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case StringLiteralForKindTest:
      case NCNameForPI:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NCNameForPI:
          jj_consume_token(NCNameForPI);
                                                                                          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTNCNAMEFORPI);
                                                                                          boolean jjtc001 = true;
                                                                                          jjtree.openNodeScope(jjtn001);
          try {
                                                                                          jjtree.closeNodeScope(jjtn001,  true);
                                                                                          jjtc001 = false;
                                                                                         jjtn001.processToken(token);
          } finally {
                                                                                          if (jjtc001) {
                                                                                            jjtree.closeNodeScope(jjtn001,  true);
                                                                                          }
          }
          break;
        case StringLiteralForKindTest:
          jj_consume_token(StringLiteralForKindTest);
                                                                                                                                                                        SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSTRINGLITERALFORKINDTEST);
                                                                                                                                                                        boolean jjtc002 = true;
                                                                                                                                                                        jjtree.openNodeScope(jjtn002);
          try {
                                                                                                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                                                        jjtc002 = false;
                                                                                                                                                    jjtn002.processToken(token);
          } finally {
                                                                                                                                                                        if (jjtc002) {
                                                                                                                                                                          jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                                                                        }
          }
          break;
        default:
          jj_la1[78] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void DocumentTest() throws ParseException {
 /*@bgen(jjtree) DocumentTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTDOCUMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DocumentLpar:
        jj_consume_token(DocumentLpar);
        break;
      case DocumentLparForKindTest:
        jj_consume_token(DocumentLparForKindTest);
        break;
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ElementType:
      case ElementTypeForKindTest:
      case ElementTypeForDocumentTest:
        ElementTest();
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      jj_consume_token(RparForKindTest);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void CommentTest() throws ParseException {
 /*@bgen(jjtree) CommentTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTCOMMENTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CommentLpar:
        jj_consume_token(CommentLpar);
        break;
      case CommentLparForKindTest:
        jj_consume_token(CommentLparForKindTest);
        break;
      default:
        jj_la1[82] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void TextTest() throws ParseException {
 /*@bgen(jjtree) TextTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTTEXTTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TextLpar:
        jj_consume_token(TextLpar);
        break;
      case TextLparForKindTest:
        jj_consume_token(TextLparForKindTest);
        break;
      default:
        jj_la1[83] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void AnyKindTest() throws ParseException {
 /*@bgen(jjtree) AnyKindTest */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTANYKINDTEST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NodeLpar:
        jj_consume_token(NodeLpar);
        break;
      case NodeLparForKindTest:
        jj_consume_token(NodeLparForKindTest);
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RparForKindTest);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SchemaContextPath() throws ParseException {
 /*@bgen(jjtree) SchemaContextPath */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSCHEMACONTEXTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(SchemaGlobalContextSlash);
                              SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSCHEMAGLOBALCONTEXTSLASH);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
      try {
                              jjtree.closeNodeScope(jjtn001,  true);
                              jjtc001 = false;
                             jjtn001.processToken(token);
      } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  true);
                              }
      }
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SchemaContextStepSlash:
          ;
          break;
        default:
          jj_la1[85] = jj_gen;
          break label_14;
        }
        jj_consume_token(SchemaContextStepSlash);
                                                                                                                      SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTSCHEMACONTEXTSTEPSLASH);
                                                                                                                      boolean jjtc002 = true;
                                                                                                                      jjtree.openNodeScope(jjtn002);
        try {
                                                                                                                      jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                      jjtc002 = false;
                                                                                     jjtn002.processToken(token);
        } finally {
                                                                                                                      if (jjtc002) {
                                                                                                                        jjtree.closeNodeScope(jjtn002,  true);
                                                                                                                      }
        }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void LocalName() throws ParseException {
 /*@bgen(jjtree) LocalName */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTLOCALNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(QNameForItemType);
                      SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTQNAMEFORITEMTYPE);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  true);
                      jjtc001 = false;
                     jjtn001.processToken(token);
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  true);
                      }
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void NodeName() throws ParseException {
 /*@bgen(jjtree) NodeName */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTNODENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QNameForItemType:
        jj_consume_token(QNameForItemType);
                       SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTQNAMEFORITEMTYPE);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
        try {
                       jjtree.closeNodeScope(jjtn001,  true);
                       jjtc001 = false;
                      jjtn001.processToken(token);
        } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  true);
                       }
        }
        break;
      case AnyName:
        jj_consume_token(AnyName);
                                                                                         SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTANYNAME);
                                                                                         boolean jjtc002 = true;
                                                                                         jjtree.openNodeScope(jjtn002);
        try {
                                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                                         jjtc002 = false;
                                                                jjtn002.processToken(token);
        } finally {
                                                                                         if (jjtc002) {
                                                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                                                         }
        }
        break;
      default:
        jj_la1[86] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void TypeName() throws ParseException {
 /*@bgen(jjtree) TypeName */
  SimpleNode jjtn000 = (SimpleNode)SimpleNode.jjtCreate(this, JJTTYPENAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QNameForItemType:
        jj_consume_token(QNameForItemType);
                       SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTQNAMEFORITEMTYPE);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
        try {
                       jjtree.closeNodeScope(jjtn001,  true);
                       jjtc001 = false;
                      jjtn001.processToken(token);
        } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  true);
                       }
        }
        break;
      case AnyName:
        jj_consume_token(AnyName);
                                                                                         SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTANYNAME);
                                                                                         boolean jjtc002 = true;
                                                                                         jjtree.openNodeScope(jjtn002);
        try {
                                                                                         jjtree.closeNodeScope(jjtn002,  true);
                                                                                         jjtc002 = false;
                                                                jjtn002.processToken(token);
        } finally {
                                                                                         if (jjtc002) {
                                                                                           jjtree.closeNodeScope(jjtn002,  true);
                                                                                         }
        }
        break;
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void OccurrenceIndicator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OccurrenceZeroOrOne:
      jj_consume_token(OccurrenceZeroOrOne);
                          SimpleNode jjtn001 = (SimpleNode)SimpleNode.jjtCreate(this, JJTOCCURRENCEZEROORONE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
      try {
                          jjtree.closeNodeScope(jjtn001,  true);
                          jjtc001 = false;
                         jjtn001.processToken(token);
      } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  true);
                          }
      }
      break;
    case OccurrenceZeroOrMore:
      jj_consume_token(OccurrenceZeroOrMore);
                                                                                                            SimpleNode jjtn002 = (SimpleNode)SimpleNode.jjtCreate(this, JJTOCCURRENCEZEROORMORE);
                                                                                                            boolean jjtc002 = true;
                                                                                                            jjtree.openNodeScope(jjtn002);
      try {
                                                                                                            jjtree.closeNodeScope(jjtn002,  true);
                                                                                                            jjtc002 = false;
                                                                                jjtn002.processToken(token);
      } finally {
                                                                                                            if (jjtc002) {
                                                                                                              jjtree.closeNodeScope(jjtn002,  true);
                                                                                                            }
      }
      break;
    case OccurrenceOneOrMore:
      jj_consume_token(OccurrenceOneOrMore);
                                                                                                                                                                                              SimpleNode jjtn003 = (SimpleNode)SimpleNode.jjtCreate(this, JJTOCCURRENCEONEORMORE);
                                                                                                                                                                                              boolean jjtc003 = true;
                                                                                                                                                                                              jjtree.openNodeScope(jjtn003);
      try {
                                                                                                                                                                                              jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                              jjtc003 = false;
                                                                                                                                      jjtn003.processToken(token);
      } finally {
                                                                                                                                                                                              if (jjtc003) {
                                                                                                                                                                                                jjtree.closeNodeScope(jjtn003,  true);
                                                                                                                                                                                              }
      }
      break;
    default:
      jj_la1[88] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  public XPathTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[89];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x3ffe1e0,0x0,0x0,0x0,0x12000,0x0,0x0,0x12000,0x0,0x0,0x12000,0x12000,0x0,0x100,0x3ffe1e0,0x0,0x0,0x0,0x4000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0000000,0xf0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x3ffe1e0,0x3ffe1e0,0x0,0x0,0x3ffe1e0,0x3ffe000,0x1e0,0x0,0x0,0x0,0x0,0x0,0x1576000,0x2a88000,0x0,0x1576000,0x2a88000,0x0,0x0,0x0,0x1e0,0xe0,0x3ffe1e0,0x0,0x0,0x3ffe1e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x1e8c0000,0x0,0x2000,0x2000,0x68c0000,0x60000000,0x60000000,0x1e8c0000,0x60000000,0x60000000,0x0,0x0,0x0,0x0,0x1e8c0000,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x10000,0x0,0x80000000,0x80000000,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x2000,0x5000,0x5000,0x68c0000,0x1e8c0000,0x60000000,0x60000000,0x68c0000,0x68c0000,0x0,0x0,0x80000000,0x0,0x0,0x0,0x68c0000,0x0,0x0,0x0,0x0,0x68c0000,0x6800000,0x6800000,0x0,0x0,0x1e8c0000,0x0,0x0,0x1e8c0000,0x0,0x0,0x1e0000,0xe0000,0xc0000,0x40000,0x2,0x0,0x1000004,0x1000004,0x80000,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x20,0x1000000,0x1000000,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0xe1860000,0x0,0x400000,0x400000,0x1000000,0x0,0x0,0x1000000,0x0,0x0,0x1000000,0x1000000,0x0,0x0,0xe1860000,0x0,0x60000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7fff,0x7fff,0x0,0x18000,0x18000,0x0,0x0,0x60000,0x60000,0x400000,0x400000,0x0,0x0,0x1800000,0x1800000,0x0,0x0,0x1800000,0x1000000,0x800000,0x2000000,0x602a,0x1f80,0x5,0x50,0x1000000,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1860000,0x0,0x0,0xe1860000,0x80000,0x380000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x380000,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0xf119fff8,0x20000,0x0,0x0,0x1000fff8,0x0,0x0,0x7000fff8,0x0,0x0,0x0,0x0,0x60000000,0x1000000,0xf119fff8,0x20000,0x0,0x20000,0x0,0x0,0x0,0x2,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf118fff8,0xf118fff8,0x0,0x0,0xf118fff8,0x1010fff8,0xe1080000,0x0,0x0,0x0,0x0,0x0,0x1000fff8,0x100000,0x0,0x0,0x0,0x1000fff8,0x10000000,0x0,0x0,0x0,0xf119fff8,0xe0000000,0x20000,0xf119fff8,0x0,0x0,0x400fff8,0x400fff8,0xfff8,0x600,0x0,0x40000,0x8000000,0x8000000,0x800,0x40000,0x0,0x0,0x1100,0x0,0x0,0x18,0x600,0x4040,0x2080,0x8020,0x0,0x8000000,0x8000000,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  public XPath(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XPathTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
  }

  public XPath(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XPathTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
  }

  public XPath(XPathTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
  }

  public void ReInit(XPathTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 89; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[137];
    for (int i = 0; i < 137; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 89; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 137; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

                }
