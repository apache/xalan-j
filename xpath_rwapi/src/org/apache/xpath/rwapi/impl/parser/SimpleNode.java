/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package org.apache.xpath.rwapi.impl.parser;

import org.apache.xpath.rwapi.impl.CastExprImpl;
import org.apache.xpath.rwapi.impl.CastableExprImpl;
import org.apache.xpath.rwapi.impl.ConditionalExprImpl;
import org.apache.xpath.rwapi.impl.ForAndQuantifiedExprImpl;
import org.apache.xpath.rwapi.impl.FunctionCallImpl;
import org.apache.xpath.rwapi.impl.InstanceOfExprImpl;
import org.apache.xpath.rwapi.impl.KindTestImpl;
import org.apache.xpath.rwapi.impl.LiteralImpl;
import org.apache.xpath.rwapi.impl.NameTestImpl;
import org.apache.xpath.rwapi.impl.OperatorImpl;
import org.apache.xpath.rwapi.impl.PathExprImpl;
import org.apache.xpath.rwapi.impl.StepExprImpl;
import org.apache.xpath.rwapi.impl.VariableImpl;

public class SimpleNode implements Node {
	static protected final boolean PRODUCE_RAW_TREE = false;
	protected Node parent; // to remove
	protected Node[] children; // to remove
	protected int id; // to remove
	//	protected XPath parser;

	protected SimpleNode() {
	}
	

	public SimpleNode(int i) {
		id = i;
	}

	public SimpleNode(XPath p, int i) {
		this(i);
		//		parser = p;
	}

	public static Node jjtCreate(XPath p, int id) {
		if (PRODUCE_RAW_TREE) {
			return new SimpleNode(p, id);
		}

		Node newNode;
		switch (id) {
			case XPathTreeConstants.JJTNAMETEST :
				newNode = new NameTestImpl(id);
				break;
			case XPathTreeConstants.JJTQNAME :
			case XPathTreeConstants.JJTQNAMELPAR :
			case XPathTreeConstants.JJTSTAR :
			case XPathTreeConstants.JJTNCNAMECOLONSTAR :
			case XPathTreeConstants.JJTSTARCOLONNCNAME :
				newNode = new QName(id);
				break;
			case XPathTreeConstants.JJTKINDTEST : //68;
				newNode = new KindTestImpl(id);
				break;
			case XPathTreeConstants.JJTPROCESSINGINSTRUCTIONTEST : //69;  
			case XPathTreeConstants.JJTCOMMENTTEST : //71;
			case XPathTreeConstants.JJTTEXTTEST : //72;
			case XPathTreeConstants.JJTANYKINDTEST : //73;  
				newNode = new KindTest(id);
				break;
			case XPathTreeConstants.JJTSTEPEXPR : //42;    
				newNode = new StepExprImpl(id);
				break;
			case XPathTreeConstants.JJTAXISCHILD :
				newNode = Axis.AXIS_CHILD;
				break;
			case XPathTreeConstants.JJTAXISATTRIBUTE :
				newNode = Axis.AXIS_ATTRIBUTE;
				break;

			case XPathTreeConstants.JJTAXISDESCENDANT :
				newNode = Axis.AXIS_DESCENDANT;
				break;

			case XPathTreeConstants.JJTAXISSELF :
				newNode = Axis.AXIS_SELF;
				break;

			case XPathTreeConstants.JJTAXISDESCENDANTORSELF :
				newNode = Axis.AXIS_DESCENDANTORSELF;
				break;

			case XPathTreeConstants.JJTAXISFOLLOWINGSIBLING :
				newNode = Axis.AXIS_FOLLOWINGSIBLING;
				break;

			case XPathTreeConstants.JJTAXISFOLLOWING :
				newNode = Axis.AXIS_FOLLOWING;
				break;

			case XPathTreeConstants.JJTAXISNAMESPACE :
				newNode = Axis.AXIS_NAMESPACE;
				break;

			case XPathTreeConstants.JJTAXISPARENT :
				newNode = Axis.AXIS_PARENT;
				break;

			case XPathTreeConstants.JJTAXISANCESTOR :
				newNode = Axis.AXIS_ANCESTOR;
				break;

			case XPathTreeConstants.JJTAXISPRECEDINGSIBLING :
				newNode = Axis.AXIS_PRECEDINGSIBLING;
				break;

			case XPathTreeConstants.JJTAXISPRECEDING :
				newNode = Axis.AXIS_PRECEDING;
				break;

			case XPathTreeConstants.JJTAXISANCESTORORSELF :
				newNode = Axis.AXIS_ANCESTORORSELF;
				break;
			case XPathTreeConstants.JJTDOT :
				newNode = new SimpleNode(id);
				break;
			case XPathTreeConstants.JJTDOTDOT :
				newNode = Singletons.DOTDOT;
				break;
			case XPathTreeConstants.JJTAT :
				newNode = Singletons.AT;
				break;
			case XPathTreeConstants.JJTUNARYEXPR :
				newNode = new OperatorImpl(id);
				break;
			case XPathTreeConstants.JJTINTEGERLITERAL :
			case XPathTreeConstants.JJTDOUBLELITERAL :
			case XPathTreeConstants.JJTSTRINGLITERAL :
			case XPathTreeConstants.JJTDECIMALLITERAL :
				newNode = new LiteralImpl(id);
				break;
			case XPathTreeConstants.JJTCASTEXPR :
				newNode = new CastExprImpl(id);
				break;
			case XPathTreeConstants.JJTCASTABLEEXPR :
				newNode = new CastableExprImpl(id);
				break;
			case XPathTreeConstants.JJTINSTANCEOFEXPR :
				newNode = new InstanceOfExprImpl(id);
				break;
			case XPathTreeConstants.JJTQUANTIFIEDEXPR :
			case XPathTreeConstants.JJTFLWREXPR :
				newNode = new ForAndQuantifiedExprImpl(id);
				break;
			case XPathTreeConstants.JJTIFEXPR :
				newNode = new ConditionalExprImpl(id);
				break;
			case XPathTreeConstants.JJTEXPRSEQUENCE :
				newNode = new OperatorImpl(id);
				break;
			case XPathTreeConstants.JJTXPATH :
				newNode = XPathNode.m_singleton;
				break;
			case XPathTreeConstants.JJTXPATH2 :
				newNode = XPath2Node.m_singleton;
				break;
			case XPathTreeConstants.JJTPATHEXPR :
				newNode = new PathExprImpl(id);
				break;

			case XPathTreeConstants.JJTSLASH :
				newNode = Singletons.SLASH;
				break;
			case XPathTreeConstants.JJTNODETEST :
				newNode = new SimpleNode(id); //Singletons.NODETEST;
				break;

			case XPathTreeConstants.JJTPREDICATES :
				newNode = new Predicates(id); // can use a singleton
				break;
			case XPathTreeConstants.JJTFUNCTIONCALL :
				newNode = new FunctionCallImpl(id);
				break;
			case XPathTreeConstants.JJTVARNAME :
				newNode = new VariableImpl(id);
				break;

			case XPathTreeConstants.JJTROOT :
				newNode = Singletons.ROOT;
				break;
			case XPathTreeConstants.JJTROOTDESCENDANTS :
				newNode = Singletons.ROOTDESCENDANT;
				break;
			case XPathTreeConstants.JJTADDITIVEEXPR :
			case XPathTreeConstants.JJTMULTIPLICATIVEEXPR :
			case XPathTreeConstants.JJTUNIONEXPR :
				newNode = new OperatorImpl(id);
				break;
			case XPathTreeConstants.JJTMATCHPATTERN :
			case XPathTreeConstants.JJTPATTERN :
			case XPathTreeConstants.JJTPATHPATTERN :
			case XPathTreeConstants.JJTSLASHSLASH :
			case XPathTreeConstants.JJTVOID :
			case XPathTreeConstants.JJTPATTERNSTEP :

			case XPathTreeConstants.JJTIDKEYPATTERN :
			case XPathTreeConstants.JJTOREXPR :
			case XPathTreeConstants.JJTANDEXPR :
			case XPathTreeConstants.JJTRETURN :
			case XPathTreeConstants.JJTSOME :
			case XPathTreeConstants.JJTEVERY :
			case XPathTreeConstants.JJTIN :
			case XPathTreeConstants.JJTSATISFIES :
			case XPathTreeConstants.JJTIFLPAR :
			case XPathTreeConstants.JJTTHEN :
			case XPathTreeConstants.JJTELSE :
			case XPathTreeConstants.JJTINSTANCEOF : //31;
			case XPathTreeConstants.JJTCOMPARISONEXPR : //32;
			case XPathTreeConstants.JJTRANGEEXPR : //33;
			case XPathTreeConstants.JJTINTERSECTEXCEPTEXPR : //37;

			case XPathTreeConstants.JJTMINUS : //39;
			case XPathTreeConstants.JJTPLUS : //40;
			case XPathTreeConstants.JJTVALIDATEEXPR : //44;
			case XPathTreeConstants.JJTRBRACE : //47;
			case XPathTreeConstants.JJTCASTAS : //49;
			case XPathTreeConstants.JJTTREATAS : //50;

			case XPathTreeConstants.JJTLBRACK : //78;
			case XPathTreeConstants.JJTRBRACK : //79;
			case XPathTreeConstants.JJTSCHEMACONTEXT : //84;
			case XPathTreeConstants.JJTSCHEMAGLOBALCONTEXT : //85;
			case XPathTreeConstants.JJTSCHEMACONTEXTSTEP : //87;
			case XPathTreeConstants.JJTSEQUENCETYPE : //88;
			case XPathTreeConstants.JJTEMPTY : //89;
			case XPathTreeConstants.JJTITEMTYPE : //90;
			case XPathTreeConstants.JJTELEMENTTYPE : //91;
			case XPathTreeConstants.JJTATTRIBUTETYPE : //92;
			case XPathTreeConstants.JJTNODE : //93;
			case XPathTreeConstants.JJTPROCESSINGINSTRUCTION : //94;
			case XPathTreeConstants.JJTCOMMENT : //95;
			case XPathTreeConstants.JJTTEXT : //96;
			case XPathTreeConstants.JJTDOCUMENT : //97;
			case XPathTreeConstants.JJTITEM : //98;
			case XPathTreeConstants.JJTUNTYPED : //99;
			case XPathTreeConstants.JJTATOMICVALUE : //100;
			case XPathTreeConstants.JJTELEMORATTRTYPE : //101;
			case XPathTreeConstants.JJTSCHEMATYPE : //102;
			case XPathTreeConstants.JJTOFTYPE : //103;
			case XPathTreeConstants.JJTATOMICTYPE : //104;
			case XPathTreeConstants.JJTOCCURRENCEINDICATOR : //105;
			case XPathTreeConstants.JJTMULTIPLY : //106;
			case XPathTreeConstants.JJTQMARK : //107;

			default :
				newNode = new SimpleNode(p, id);
		}

		return newNode;
	}

	public static Node jjtCreate(int id) {
		// When this one is called?
		return new SimpleNode(id);
	}

	public void jjtOpen() {
	}

	public void jjtClose() {
	}

	public void jjtSetParent(Node n) {
		parent = n;
	}
	public Node jjtGetParent() {
		return parent;
	}

	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;

	}

	/**
	 * Insert child at the first position
	 */
	public void jjtInsertChild(Node n) {
		if (children == null) {
			children = new Node[1];
		} else {
			Node c[] = new Node[children.length + 1];
			System.arraycopy(children, 0, c, 1, children.length);
			children = c;
		}
		children[0] = n;

	}

	public Node jjtGetChild(int i) {
		return children[i];
	}

	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	/** Accept the visitor. **/
	public Object jjtAccept(XPathVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}

	/** Accept the visitor. **/
	public Object childrenAccept(XPathVisitor visitor, Object data) {
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				children[i].jjtAccept(visitor, data);
			}
		}
		return data;
	}

	/**
	* @see org.apache.xpath.rwapi.impl.parser.Node#getId()
	*/
	public int getId() {
		return id;
	}

	/**
	     * Method processToken.
	     * @param token
	     */
	public void processToken(Token token) {
	}

	/**
	 * 
	 */
	public boolean canBeReduced() {
		return false;
	}

	/* You can override these two methods in subclasses of SimpleNode to
	   customize the way the node appears when the tree is dumped.  If
	   your output uses more than one line you should override
	   toString(String), otherwise overriding toString() is probably all
	   you need to do. */

	public String toString() {
		return XPathTreeConstants.jjtNodeName[id] + " classname=" + getClass();
	}
	public String toString(String prefix) {
		return prefix + toString();

	}

	/* Override this method if you want to customize how the node dumps
	   out its children. */

	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}

}
