/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package org.apache.xpath.rwapi.impl.parser;

import org.apache.xpath.rwapi.impl.CastExprImpl;
import org.apache.xpath.rwapi.impl.CastableExprImpl;
import org.apache.xpath.rwapi.impl.ConditionalExprImpl;
import org.apache.xpath.rwapi.impl.ForAndQuantifiedExprImpl;
import org.apache.xpath.rwapi.impl.FunctionCallImpl;
import org.apache.xpath.rwapi.impl.InstanceOfExprImpl;
import org.apache.xpath.rwapi.impl.KindTestImpl;
import org.apache.xpath.rwapi.impl.LiteralImpl;
import org.apache.xpath.rwapi.impl.NameTestImpl;
import org.apache.xpath.rwapi.impl.OperatorImpl;
import org.apache.xpath.rwapi.impl.PathExprImpl;
import org.apache.xpath.rwapi.impl.StepExprImpl;
import org.apache.xpath.rwapi.impl.VariableImpl;


/**
 *
 */
public class SimpleNode implements Node
{
    static public boolean PRODUCE_RAW_TREE = false;
    final static private NodeFactory DEFAULT_NODE_FACTORY = new DefaultNodeFactory();
    protected Node parent; // to remove
    protected Node[] children; // to remove
    protected int id; // to remove

    protected SimpleNode()
    {
    }

    public SimpleNode(int i)
    {
        id = i;
    }

    public SimpleNode(XPath p, int i)
    {
        this(i);
    }

    public static Node jjtCreate(XPath p, int id)
    {
        if (PRODUCE_RAW_TREE)
        {
            return new SimpleNode(p, id);
        }

        Node newNode;
        NodeFactory nodeFactory = (p.m_nodeFactory == null) ? DEFAULT_NODE_FACTORY : p.m_nodeFactory;

        switch (id)
        {
            case XPathTreeConstants.JJTNAMETEST:
                newNode = nodeFactory.createNameTestNode(id);

                if (newNode == null)
                {
                    newNode = new NameTestImpl(id);
                }

                break;

            case XPathTreeConstants.JJTPROCESSINGINSTRUCTIONTEST:			
            case XPathTreeConstants.JJTCOMMENTTEST:
            case XPathTreeConstants.JJTTEXTTEST:
            case XPathTreeConstants.JJTANYKINDTEST:
                newNode = nodeFactory.createKindTestNode(id);

                if (newNode == null)
                {
                    newNode = new KindTestImpl(id);
                }

                break;

            case XPathTreeConstants.JJTSTEPEXPR:
                newNode = nodeFactory.createStepNode(id);

                if (newNode == null)
                {
                    newNode = new StepExprImpl(id);
                }

                break;

            

            case XPathTreeConstants.JJTINTEGERLITERAL:
            case XPathTreeConstants.JJTDOUBLELITERAL:
            case XPathTreeConstants.JJTSTRINGLITERAL:
            case XPathTreeConstants.JJTDECIMALLITERAL:
                newNode = (LiteralImpl) nodeFactory.createLiteralNode(id);

                if (newNode == null)
                {
                    newNode = new LiteralImpl(id);
                }

                break;

            case XPathTreeConstants.JJTCASTEXPR:
                newNode = (CastExprImpl) nodeFactory.createNode(id);

                if (newNode == null)
                {
                    newNode = new CastExprImpl(id);
                }

                break;

            case XPathTreeConstants.JJTCASTABLEEXPR:
                newNode = (CastableExprImpl) nodeFactory.createNode(id);

                if (newNode == null)
                {
                    newNode = new CastableExprImpl(id);
                }

                break;

            case XPathTreeConstants.JJTINSTANCEOFEXPR:
                newNode = (InstanceOfExprImpl) nodeFactory.createNode(id);

                if (newNode == null)
                {
                    newNode = new InstanceOfExprImpl(id);
                }

                break;

            case XPathTreeConstants.JJTQUANTIFIEDEXPR:
            case XPathTreeConstants.JJTFLWREXPR:
                newNode = (ForAndQuantifiedExprImpl) nodeFactory.createNode(id);

                if (newNode == null)
                {
                    newNode = new ForAndQuantifiedExprImpl(id);
                }

                break;

            case XPathTreeConstants.JJTIFEXPR:
                newNode = (ConditionalExprImpl) nodeFactory.createNode(id);

                if (newNode == null)
                {
                    newNode = new ConditionalExprImpl(id);
                }

                break;

          
        

            case XPathTreeConstants.JJTPATHEXPR:
                newNode = nodeFactory.createPathNode(id);

                if (newNode == null)
                {
                    newNode = new PathExprImpl(id);
                }

                break;

			case XPathTreeConstants.JJTEXPRSEQUENCE:
			case XPathTreeConstants.JJTUNARYEXPR:
            case XPathTreeConstants.JJTADDITIVEEXPR:
            case XPathTreeConstants.JJTMULTIPLICATIVEEXPR:
            case XPathTreeConstants.JJTUNIONEXPR:
            case XPathTreeConstants.JJTRANGEEXPR:
            case XPathTreeConstants.JJTOREXPR:
            case XPathTreeConstants.JJTANDEXPR:
            case XPathTreeConstants.JJTCOMPARISONEXPR:
                newNode = nodeFactory.createOperatorNode(id);

                if (newNode == null)
                {
                    newNode = new OperatorImpl(id);
                }

                break;

            case XPathTreeConstants.JJTFUNCTIONCALL:
                newNode = nodeFactory.createFunctionCallNode(id);

                if (newNode == null)
                {
                    newNode = new FunctionCallImpl(id);
                }

                break;

            case XPathTreeConstants.JJTVARNAME:
                newNode = nodeFactory.createVarNameNode(id);

                if (newNode == null)
                {
                    newNode = new VariableImpl(id);
                }

                break;

            // The nodes belows are filtered: no customisation possible
            case XPathTreeConstants.JJTQNAME:
            case XPathTreeConstants.JJTQNAMELPAR:
            case XPathTreeConstants.JJTSTAR:
            case XPathTreeConstants.JJTNCNAMECOLONSTAR:
            case XPathTreeConstants.JJTSTARCOLONNCNAME:
                newNode = new QName(id);

                break;

            case XPathTreeConstants.JJTDOTDOT:
                newNode = Singletons.DOTDOT;

                break;

            case XPathTreeConstants.JJTAT:
                newNode = Singletons.AT;

                break;

            case XPathTreeConstants.JJTPLUS:
                newNode = Singletons.PLUS;

                break;

            case XPathTreeConstants.JJTMINUS:
                newNode = Singletons.MINUS;

                break;

            case XPathTreeConstants.JJTXPATH:
                newNode = XPathNode.m_singleton;

                break;

            case XPathTreeConstants.JJTXPATH2:
                newNode = XPath2Node.m_singleton;

                break;

            case XPathTreeConstants.JJTDOT:
                newNode = Singletons.DOT;

                break;

            case XPathTreeConstants.JJTSLASH:
                newNode = Singletons.SLASH;

                break;

            case XPathTreeConstants.JJTPREDICATES:
                newNode = new Predicates(id);

                // can use a singleton (but children need to be reinitialized)
                break;

            case XPathTreeConstants.JJTNODETEST:
                newNode = new SimpleNode(id); //Singletons.NODETEST; 

                // can use a singleton (but children need to be reinitialized)
                break;

            case XPathTreeConstants.JJTROOT:
                newNode = Singletons.ROOT;

                break;

            case XPathTreeConstants.JJTROOTDESCENDANTS:
                newNode = Singletons.ROOTDESCENDANT;

                break;

            case XPathTreeConstants.JJTSLASHSLASH:
                newNode = Singletons.SLASHSLASH;

                break;

            case XPathTreeConstants.JJTAXISCHILD:
                newNode = Axis.AXIS_CHILD;

                break;

            case XPathTreeConstants.JJTAXISATTRIBUTE:
                newNode = Axis.AXIS_ATTRIBUTE;

                break;

            case XPathTreeConstants.JJTAXISDESCENDANT:
                newNode = Axis.AXIS_DESCENDANT;

                break;

            case XPathTreeConstants.JJTAXISSELF:
                newNode = Axis.AXIS_SELF;

                break;

            case XPathTreeConstants.JJTAXISDESCENDANTORSELF:
                newNode = Axis.AXIS_DESCENDANTORSELF;

                break;

            case XPathTreeConstants.JJTAXISFOLLOWINGSIBLING:
                newNode = Axis.AXIS_FOLLOWINGSIBLING;

                break;

            case XPathTreeConstants.JJTAXISFOLLOWING:
                newNode = Axis.AXIS_FOLLOWING;

                break;

            case XPathTreeConstants.JJTAXISNAMESPACE:
                newNode = Axis.AXIS_NAMESPACE;

                break;

            case XPathTreeConstants.JJTAXISPARENT:
                newNode = Axis.AXIS_PARENT;

                break;

            case XPathTreeConstants.JJTAXISANCESTOR:
                newNode = Axis.AXIS_ANCESTOR;

                break;

            case XPathTreeConstants.JJTAXISPRECEDINGSIBLING:
                newNode = Axis.AXIS_PRECEDINGSIBLING;

                break;

            case XPathTreeConstants.JJTAXISPRECEDING:
                newNode = Axis.AXIS_PRECEDING;

                break;

            case XPathTreeConstants.JJTAXISANCESTORORSELF:
                newNode = Axis.AXIS_ANCESTORORSELF;

                break;

            case XPathTreeConstants.JJTMATCHPATTERN:
            case XPathTreeConstants.JJTPATTERN:
            case XPathTreeConstants.JJTPATHPATTERN:
            case XPathTreeConstants.JJTVOID:
            case XPathTreeConstants.JJTPATTERNSTEP:
            case XPathTreeConstants.JJTIDKEYPATTERN:
            case XPathTreeConstants.JJTRETURN:
            case XPathTreeConstants.JJTSOME:
            case XPathTreeConstants.JJTEVERY:
            case XPathTreeConstants.JJTIN:
            case XPathTreeConstants.JJTSATISFIES:
            case XPathTreeConstants.JJTIFLPAR:
            case XPathTreeConstants.JJTTHEN:
            case XPathTreeConstants.JJTELSE:
            case XPathTreeConstants.JJTINSTANCEOF: //31;
            case XPathTreeConstants.JJTINTERSECTEXCEPTEXPR: //37;           
            case XPathTreeConstants.JJTVALIDATEEXPR: //44;
            case XPathTreeConstants.JJTRBRACE: //47;
            case XPathTreeConstants.JJTCASTAS: //49;
            case XPathTreeConstants.JJTTREATAS: //50;
            case XPathTreeConstants.JJTSCHEMACONTEXT: //84;
            case XPathTreeConstants.JJTSCHEMAGLOBALCONTEXT: //85;
            case XPathTreeConstants.JJTSCHEMACONTEXTSTEP: //87;
            case XPathTreeConstants.JJTSEQUENCETYPE: //88;
            case XPathTreeConstants.JJTEMPTY: //89;
            case XPathTreeConstants.JJTITEMTYPE: //90;
            case XPathTreeConstants.JJTELEMENTTYPE: //91;
            case XPathTreeConstants.JJTATTRIBUTETYPE: //92;
            case XPathTreeConstants.JJTNODE: //93;
            case XPathTreeConstants.JJTPROCESSINGINSTRUCTION: //94;
            case XPathTreeConstants.JJTCOMMENT: //95;
            case XPathTreeConstants.JJTTEXT: //96;
            case XPathTreeConstants.JJTDOCUMENT: //97;
            case XPathTreeConstants.JJTITEM: //98;
            case XPathTreeConstants.JJTUNTYPED: //99;
            case XPathTreeConstants.JJTATOMICVALUE: //100;
            case XPathTreeConstants.JJTELEMORATTRTYPE: //101;
            case XPathTreeConstants.JJTSCHEMATYPE: //102;
            case XPathTreeConstants.JJTOFTYPE: //103;
            case XPathTreeConstants.JJTATOMICTYPE: //104;
            case XPathTreeConstants.JJTOCCURRENCEINDICATOR: //105;
            case XPathTreeConstants.JJTMULTIPLY: //106;
            case XPathTreeConstants.JJTQMARK: //107;
            

            default:

                //System.err.println("case not implemented: " + XPathTreeConstants.jjtNodeName[id]);
                newNode = new SimpleNode(p, id);
        }

        return newNode;
    }

    public static Node jjtCreate(int id)
    {
        // When this one is called?
        return new SimpleNode(id);
    }

    public void jjtOpen()
    {
    }

    public void jjtClose()
    {
    }

    public void jjtSetParent(Node n)
    {
        parent = n;
    }

    public Node jjtGetParent()
    {
        return parent;
    }

    public void jjtAddChild(Node n, int i)
    {
        if (children == null)
        {
            children = new Node[i + 1];
        }
        else if (i >= children.length)
        {
            Node[] c = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }

        children[i] = n;
    }

    /**
     * Insert child at the first position
     */
    public void jjtInsertChild(Node n)
    {
        if (children == null)
        {
            children = new Node[1];
        }
        else
        {
            Node[] c = new Node[children.length + 1];
            System.arraycopy(children, 0, c, 1, children.length);
            children = c;
        }

        children[0] = n;
    }

    /**
     * Insert children of the given node at the first position
     */
    public void jjtInsertNodeChildren(Node sn)
    {
        Node[] n = ((SimpleNode) sn).children;

        if (n != null)
        {
            if (children == null)
            {
                children = new Node[n.length];
            }
            else
            {
                Node[] c = new Node[children.length + n.length];
                System.arraycopy(children, 0, c, n.length, children.length);
                children = c;
            }

            System.arraycopy(n, 0, children, 0, n.length);
        }
    }

    public Node jjtGetChild(int i)
    {
        return children[i];
    }

    public int jjtGetNumChildren()
    {
        return (children == null) ? 0 : children.length;
    }

    /** Accept the visitor. **/
    public Object jjtAccept(XPathVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    /** Accept the visitor. **/
    public Object childrenAccept(XPathVisitor visitor, Object data)
    {
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                children[i].jjtAccept(visitor, data);
            }
        }

        return data;
    }

    /**
    * @see org.apache.xpath.rwapi.impl.parser.Node#getId()
    */
    public int getId()
    {
        return id;
    }

    /**
         * Method processToken.
         * @param token
         */
    public void processToken(Token token)
    {
    }

    /**
     *
     */
    public boolean canBeReduced()
    {
        return false;
    }

    /* You can override these two methods in subclasses of SimpleNode to
       customize the way the node appears when the tree is dumped.  If
       your output uses more than one line you should override
       toString(String), otherwise overriding toString() is probably all
       you need to do. */
    public String toString()
    {
        return XPathTreeConstants.jjtNodeName[id] + " classname=" + getClass();
    }

    public String toString(String prefix)
    {
        return prefix + toString();
    }

    public void dump(String prefix)
    {
        dump(prefix, System.out);
    }

    /* Override this method if you want to customize how the node dumps
       out its children. */
    public void dump(String prefix, java.io.PrintStream out)
    {
        out.println(toString(prefix));

        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];

                if (n != null)
                {
                    n.dump(prefix + " ", out);
                }
            }
        }
    }

}
