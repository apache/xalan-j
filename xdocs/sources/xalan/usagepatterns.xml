<?xml version="1.0" standalone="no"?> 
<!DOCTYPE s1 SYSTEM "sbk:/style/dtd/document.dtd">
<!--
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xalan" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, Lotus
 * Development Corporation., http://www.lotus.com.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 -->
<s1 title="Basic usage patterns">
<ul>
<li><link anchor="basic">Basic steps</link></li>
<li><link anchor="xmlreader">Setting the XMLReader</link></li>
<li><link anchor="embed">Working with embedded stylesheets</link></li>
<li><link anchor="params">Setting stylesheet parameters</link></li>
<li><link anchor="sax">Explicitly working with SAX</link></li>
<li><link anchor="outasin">Using transformation output as input for another transformation</link></li>
<li><link anchor="dom">Processing and producing DOM trees</link></li>
<li><link anchor="xpath">Working with XPath expressions</link></li>
<li><link anchor="applet">Using the &xslt4j; applet wrapper</link></li>
<li><link anchor="servlet">Using &xslt4j; in a servlet</link></li>
<li><link anchor="extensions">Creating and using extensions</link></li>
<li><link anchor="multithreading">Multithreading</link></li>
<li><link anchor="debugging">Debugger interface</link></li>
</ul>
<anchor name="basic"/>
  <s2 title="Basic steps">
    <ol>
    <li><link anchor="processor">Instantiate stylesheet Processor</link></li>
    <li><link anchor="process">Process stylesheet</link></li>
    <li><link anchor="transformer">Instantiate Transformer</link></li>
    <li><link anchor="transformation">Perform transformation</link></li>
  </ol>
    <p>The following example highlights the four basic steps involved in performing a transformation.</p>
    <source>// 1. Instantiate a stylesheet Processor.
org.apache.trax.Processor processor = 
                          org.apache.trax.Processor.newInstance("xslt");

// 2. Process the stylesheet, producing a Templates object.
org.apache.trax.Templates templates = processor.process
                               (new org.xml.sax.InputSource("foo.xsl"));

// 3. Use the Templates object to instantiate a Transformer.
org.apache.trax.Transformer transformer = templates.newTransformer();

// 4. Use the Transformer to apply the Templates object to an XML
//&nbsp;&nbsp;&nbsp;&nbsp;source and send the output to a Result object.
transformer.transform
      ( new org.xml.sax.InputSource("foo.xml"), 
        new org.apache.trax.Result(new java.io.FileOutputStream("foo.out")) );</source>
  <note>For a working example of this model at its simplest, see SimpleTransform.java in the java/samples/SimpleTransform subdirectory.</note>
  </s2><anchor name="processor"/>
  <s2 title="1. Instantiate a stylesheet Processor">
  <p>The org.apache.trax.Processor static newInstance() method with "xslt" as its argument instantiates the processor designated by the org.apache.trax.processor.xslt system property.</p>
  <p>If this system property has not already been set (from the command line or in your application), org.apache.trax.Processor sets it from org/apache/trax/trax.properties (in xalan.jar).</p>
  <p>For &xslt4j;, this system property should be set to org.apache.xalan.processor.StylesheetProcessor.</p>
</s2><anchor name="process"/>
  <s2 title="2. Process the stylesheet, producing a Templates object">
  <p>The Templates object is an immutable runtime representation of the structure and content of a stylesheet (which may include
  and import multiple stylesheet sources).</p>
<p>A given Templates object may be used repeatedly and by multiple concurrent threads for the transformation of XML input.</p>
  <p>You may provide the stylesheet as a SAX input source (from a file or stream) or as a DOM tree.</p>
  <p>Use the Processor process() method with a SAX input source (as in the example above), or the processFromNode() method with a DOM tree to generate a Templates object.</p>
<p>To perform this operation with a SAX input source, the processor uses a org.apache.trax.TemplatesBuilder (extending the SAX ContentHandler interface) and a SAX XMLReader.</p>
<p>The XMLReader parses the input, sending parse events to the TemplatesBuilder, which responds by building the Templates object.</p>
<p>If you use the processFromNode() method with a DOM representation of the stylesheet, the processor traverses the DOM, sending SAX events to the TemplatesBuilder.</p>
</s2><anchor name="transformer"/>
<s2 title="3. Instantiate a Transformer">
<p>To transform an XML document, you need an implementation of the org.apache.trax.Transformer interface.</p>
<note>&xslt4j; implements the Transformer interface with org.apache.xalan.transformer.TransformerImpl.</note>
<p>You can use a Templates object for multiple transformations (even performed concurrently), but you should use the Templates object to instantiate a separate Transformer for each transformation you perform. The Templates object contains the stylesheet structure and data and XSLT schema, which are immutable, whereas the Transformer tracks state information as it performs the transformation.</p>
</s2><anchor name="transformation"/>
<s2 title="4. Perform a transformation">
<p>Supply the XML input, a target or "holder" for the transformation output, and instruct the Transformer to perform the transformation.</p>
<p>Just as with the stylesheet, you can supply the XML input in the form of a SAX input source (from a URL or stream) or a DOM tree.</p>
<p>Use the Transformer transform() method with a SAX input source (as in the example above), or the transformNode() method with a DOM tree to perform the transformation.</p>
<p>TRaX provides the holder for the output: org.apache.trax.Result. You can set up a Result object to send the transformation result to a file or stream or to build a DOM tree.</p>
<p>The Transformer uses the XMLParser to parse the XML input and sends parse events to a SAX ContentHandler, which assembles the input into a DOM tree. Of course this operation is unnecessary if the XML input is submitted as a DOM.</p>
<p>For each node in the XML source, the Transformer uses the Templates object to determine which template to apply: one of the templates in the Templates object, a default template rule as specified in the XSLT spec, or none.</p>
<p>The Transformer forwards the SAX events produced by this process to the appropriate output ContentHandler, a serializer if the Result object has been set up to write to a stream or file, a DOMBuilder utility if the output is to be a DOM tree.</p>
<note>A serializer is a utility that translates a series of SAX events or a DOM tree into a stream, performing any character escaping required by the output method (the XML ourput method, for example normally requires &lt; and &amp; to be escaped).</note>
<p>To the degree possible, the parsing of the XML source and application of the Templates object to that source are performed concurrently. This enables the Transformer to begin supplying the client with transformation output before the parsing has been completed. When necessary, the Transformer waits for the XMLReader to provide the input it needs to continue.</p>
</s2><anchor name="xmlreader"/>
<s2 title="Setting the XMLReader">
<p>Unless you are submitting your stylesheet and your XML input in the form of DOM trees, &xslt4j; uses an XMLReader to parse the stylesheet and the XML input. This XMLReader must implement the <resource-ref idref="jaxp"/>. To designate an XMLReader, do one of the following:</p>
<ul>
  <li>Set the org.xml.sax.driver system property.<br/><br/>
  You can set system properties from the command line or within your application. You can also edit the setting in org/apache/xalan/res/XSLTInfo.properties (in xalan.jar). If the org.xml.sax.driver system property is not set, &xslt4j; uses this file to set it.<br/><br/></li>
  <li>Call the org.apache.trax.Processor.setXMLReader() method.<br/><br/>
  If you call this method before you call org.apache.trax.Processor.process() to generate a Templates object, &xslt4j; uses the XMLReader you designate to process the stylesheet and the XML input, and ignores the org.xml.sax.driver property setting (for the current transformation).<br/><br/></li>
</ul>
<p>Be sure the XMLReader is on the classpath. The &xml4j; XMLReader -- org.apache.xerces.parsers.SAXParser -- is in xerces.jar.(</p>
<note>Other system properties: The default serializer system property settings are in org/apache/serialize/serializer.properties. The default XSLT stylesheet system property setting is in  org/apache/trax/trax.properties. These properties files are in xalan.jar.</note>
</s2><anchor name="params"/>
<s2 title="Setting stylesheet parameters">
<p>An XSLT stylesheet may include parameters that are set at run time each time a transformation takes place. To set a stylesheet parameter, use the org.apache.trax.Transformer <jump href="apidocs/org/apache/trax/Transformer.html#setParameter(java.lang.String,java.lang.String,java.lang.Object)">setParameter(String name, String namespace, Object value)</jump> method. If the parameter QName only includes a local name (as is often the case), the namespace argument is null. For a working example, see UseStylesheetParam.java in the  java/samples/UseStylesheetParam subdirectory.</p>
<p>You can also set a parameter with the command-line utility by including the -param flag. For example:</p>
<p><code>java org.apache.xalan.xslt.Process -in foo.xml -xsl foo.xsl -param param1 foobar</code></p>
<p>where <code>param</code> is the parameter name and <code>foobar</code> is the parameter value. The parameter namespace is null.</p>
</s2><anchor name="embed"/>
<s2 title="Working with embedded stylesheets">
<p>An XML source document may include an <jump href="http://www.w3.org/TR/xml-stylesheet/">xml-stylesheet processing instruction</jump> which identifies the stylesheet to be used to process the document. As indicated by the processing instruction href attribute, the stylesheet itself may be embedded in the XML document or located elsewhere.</p>
<p>Suppose you have an XML document (foo.xml) with the following xml-stylesheet processing instruction:</p>
<p><code>&lt;?xml-stylesheet type="text/xml" href="foo.xsl"?&gt;</code></p>
<p>The following fragment, uses this instruction to locate the stylesheet (foo.xsl in the same directory) and create a Templates object. Note the use of the Processor getAssociatedStylesheets() and processMultipleStylesheets() methods in steps 2a and 2b.</p>
<note>An XML document may include more than one xml-stylesheet processing instruction, hence the support for working with multiple stylesheets. If more than one stylesheet is returned, the other stylesheets are imported into the first stylesheet [awaiting clarification from the W3C].</note>
<source>// 1. Instantiate the stylesheet processor.
org.apache.trax.Processor processor = 
                            org.apache.trax.Processor.newInstance("xslt");

// 2a. Get the stylesheet(s) from the XML source (the source may contain
//     more than one xml-stylesheet processing instruction).
String media = null , title = null, charset = null;
org.xml.sax.InputSource[] stylesheet = processor.getAssociatedStylesheets
                      (new InputSource("foo.xml"), media, title, charset);
// 2b. Process the stylesheet(s), producing a Templates object.
org.apache.trax.Templates templates = processor.processMultiple(stylesheet);

// 3. Use the Templates object to instantiate a Transformer.
org.apache.trax.Transformer transformer = templates.newTransformer();

// 4. Use the Transformer to apply the Templates object to an XML
//&nbsp;&nbsp;&nbsp;&nbsp;source and send the output to a Result object.
transformer.transform
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new org.xml.sax.InputSource("foo.xml"), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new org.apache.trax.Result(new java.io.FileWriter("foo.out")));</source>
</s2><anchor name="sax"/>
<s2 title="Explicitly working with SAX">
  <p>&xslt4j; uses the SAX event model to process stylesheets, to parse XML input documents, and to produce output. For each of these operations, an XMLReader reads input, firing parse events, and a ContentHandler listens to the XMLReader and performs parse event methods.</p>
<p>When you use the basic procedure described above for performing transformations, &xslt4j; takes care of many of the SAX details under the covers. You are free to make these details explicit, which simply means that you can intervene in the procedure to accommodate any custom conditions in which your application operates.</p>
<p>Suppose, for example, you are using a custom XMLReader (perhaps doing more than just parsing static XML documents) to generate &xslt4j; SAX parse events. You can instruct the Transformer to provide the ContentHandler for this XMLReader. You might even have a custom reader for producing/processing stylesheets, in which case you simply set the org.apache.trax.TemplatesBuilder (implemented by the org.apache.xalan.processor.StylesheetHandler) as the ContentHandler for this reader.</p>
  <p>The following example explicitly sets up the XMLReader and ContentHandlers, and replicates the <link anchor="basic">basic steps</link> described above.</p>
  <source>// 1. Instantiate  stylesheet processor.
org.apache.trax.Processor processor = 
                          org.apache.trax.Processor.newInstance("xslt");

// 2. Process the stylesheet. producing a Templates object.
// Get the XMLReader.
org.xml.sax.XMLReader reader = 
                 org.xml.sax.helpers.XMLReaderFactory.createXMLReader();
// Set the ContentHandler.
org.apache.trax.TemplatesBuilder templatesBuilder = 
                                         processor.getTemplatesBuilder();
reader.setContentHandler(templatesBuilder);
// Set the ContentHandler to also function as a LexicalHandler, which
// includes "lexical" (e.g., comments and CDATA) events. The Xalan
// TemplatesBuilder -- org.apache.xalan.processor.StylesheetHandler -- is
// also a LexicalHandler).
if(templatesBuilder instanceof org.xml.sax.ext.LexicalHandler)
   reader.setProperty("http://xml.org/sax/properties/lexical-handler", 
                       templatesBuilder);
// Parse the stylesheet.                       
reader.parse("foo.xsl");
//Get the Templates object from the ContentHandler.
org.apache.trax.Templates templates = templatesBuilder.getTemplates();

// 3. Use the Templates object to instantiate a Transformer.
org.apache.trax.Transformer transformer = templates.newTransformer();

// 4. Perform the transformation.
// Set up the ContentHandler (a serializer) for the output.
org.apache.trax.Result result = 
          new org.apache.trax.Result(new java.io.FileWriter("foo.out"));
org.apache.xml.serialize.SerializerFactory sfactory = 
  org.apache.xml.serialize.SerializerFactory.getSerializerFactory("xml");
org.apache.xml.serialize.Serializer serializer = sfactory.makeSerializer
                         ( result.getCharacterStream(), 
                           new org.apache.xml.serialize.OutputFormat() );
transformer.setContentHandler(serializer.asContentHandler());
// Set up the ContentHandler for the input.
org.xml.sax.ContentHandler chandler = transformer.getInputContentHandler();
reader.setContentHandler(chandler);
if(chandler instanceof org.xml.sax.ext.LexicalHandler)
  reader.setProperty("http://xml.org/sax/properties/lexical-handler",chandler);
else
  reader.setProperty("http://xml.org/sax/properties/lexical-handler", null);
// Parse the XML input document. The input and output ContentHandlers work in
// separate threads to optimize performance.
reader.parse("foo.xml");</source>
</s2><anchor name="outasin"/>
<s2 title="Using transformation output as input for another transformation">
<p>You can chain together a series of two or more transformations such that the output of one transformation provides input for the another transformation. &xslt4j; supports two basic strategies for chaining a series of transformations:</p>
<ul>
  <li>A Transformer uses a SAX ContentHandler to process input, and another ContentHandler to process output. Along these lines, you can use the Transformer getInputContentHandler() method to make one Transformer the ContentHandler for the XMLReader that parses the input, then use the same method make a second Transformer the ContentHandler for the output of the first Transformer, and so on. For more detail and an example, see the <link idref="samples" anchor="pipe">Pipe</link> sample.<br/><br/></li>
  <li>A Transformer extends the SAX XMLFilter interface. Using the setParent() method this interface supplies, you can set an XMLReader as the parent of the Transformer for the first transformation, then set this Transformer as the parent for the Transformer performing the second transformation, and so on. You launch the series by instructing the last Transformer to parse the input. For more detail and an example, see the <link idref="samples" anchor="usexmlfilters">UseXMLFilters</link> sample.</li>
</ul>
</s2><anchor name="dom"/>
<s2 title="Processing and producing DOM trees">
  <p>In some cases, the input and/or desired output for a transformation may be a DOM tree object,  rather than a file or stream.</p>
<p>To process DOM input, use one of the org.apache.trax.Transformer <jump href="apidocs/org/apache/trax/Transformer.html#transformNode(org.w3c.dom.Node, org.apache.trax.Result)">transformNode()</jump> methods.</p>
  <p>To produce a transformation result in the form of a DOM tree, use the <jump href="http://java.sun.com/xml/docs/api/index.html">Java API for XML Parsing</jump> as indicated below to instantiate an empty DOM Document to hold the result tree.</p>
  <ol>
    <li>The javax.xml.parsers.DocumentBuilderFactory abstract class contains a static newInstance() method for instantiating a factory designated by the javax.xml.parsers.DocumentBuilderFactory system property.<br/><br/></li>
    <li>In turn, the factory provides a newDocumentBuilder() method with which you instantiate a DocumentBuilder.<br/><br/></li>
    <li>Use the DocumentBuilder to instantiate an empty DOM Document.<br/><br/></li>
    <li>Use this DOM Document node to construct the org.apache.trax.Result object for the transformation result tree.</li>
  </ol>
<source>javax.xml.parsers.DocumentBuilderFactory dfactory =
                      javax.xml.parsers.DocumentBuilderFactory.newInstance();
javax.xml.parsers.DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
org.w3c.dom.Document resultDoc = docBuilder.newDocument();
org.apache.trax.Result result = new org.apache.trax.Result(resultDoc);
</source>
</s2><anchor name="xpath"/>
<s2 title="Working with XPath expressions">
<p>XSLT stylesheets use XPath expressions to select nodes, specify conditions, and generate text for the result tree. XPath provides an API that you can call directly. For example, you may want to select nodes programmatically and do your own processing without a stylesheet.</p>
<p>XPath is an independent entity, with clients other than XSLT processors (such as XPointer). Accordingly, &xslt4j2; has packaged XPath as a separate module (org.apache.xpath and its subpackages), although concurrently this module does use some utility classes packaged in org.apache.xalan.utils. The org.apache.xpath.XPathAPI class contains convenience methods that you can use to return single DOM Nodes, NodeIterators, and XObjects. Apart from their own functionality, these methods also provide a path into the lower-level XPath API that you may find useful.</p>
<p>For an example that uses the XPathAPI convenience methods to execute XPath expressions against XML source files, see <link idref="samples" anchor="applyxpath">ApplyXPath</link>.</p>
</s2><anchor name="applet"/>
<s2 title="Using the &xslt4j; applet wrapper">
<ol> 
<li>Include <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html">XSLTProcessorApplet</jump> in an HTML client.<br/><br/></li>
<li>Specify the XML source document and XSL stylesheet.<br/><br/>
You can use the DocumentURL and StyleURL PARAM tags or the <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#setDocumentURL(java.lang.String)">setdocumentURL()</jump> and <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#setStyleURL(java.lang.String)">setStyleURL()</jump> methods. If the XML document contains a stylesheet Processing Instruction (PI), you do not need to specify an XSL stylesheet.<br/><br/></li>
<li>Call the <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#transformToHtml(java.lang.String,java.lang.String)">transformToHtml()</jump> method, which performs the transformation and returns the new document as a String.</li></ol>
<p>For an example, see the <jump href="../samples/appletXMLtoHTML/readme.html">sample applet readme</jump>.</p>
</s2><anchor name="servlet"/>
<s2 title="Using &xslt4j; in a servlet">
<p>You can set up a servlet to use &xslt4j; to respond to requests for XML documents by transforming those documents into HTML and serving them to clients. For a sample of how this might be done, see <link idref="samples" anchor="servlet">sample servlet</link>.</p>
</s2><anchor name="extensions"/>
<s2 title="Creating and using extensions">
<p>For those cases where you want to be able to call procedural code from within a stylesheet, the &xslt4j; Extensions facility supports the creation of extension elements and extension functions. See <link idref="extensions">Extensions</link> and <link idref="samples" anchor="extensions">Extensions samples</link>.</p>
</s2><anchor name="multithreading"/>
<s2 title="Multithreading">
<p>A given Templates object may be used concurrently iand repeatedly in multiple transformations. You must, however, use a separate Transformer object to perform each transformation. The Transformer object tracks state information and is lightweight. Each time you perform a transformation, use the Templates object newTransformer() method to instantiate a Transformer.</p>
</s2><anchor name="debugging"/>
<s2 title="Debugger Interface">
		<p>&xslt4j; contains a debugger interface in the org.apache.xalan.xslt.trace package:</p> 
		<ul>
		  <li><jump href="apidocs/org/apache/xalan/trace/TraceListener.html">TraceListener</jump> is an interface that debuggers 
		  can implement. Or, like the <link idref="commandline">command-line utility</link>, you can use the <jump
      href="apidocs/org/apache/xalan/trace/PrintTraceListener.html">PrintTraceListener</jump> implementation of that interface.
      <br/><br/></li>
      <li>You can associate a <jump href="apidocs/org/apache/xalan/trace/TraceManager.html">TraceManager</jump> with the
      Transformer for a given transformation, and register a TraceListener with the TraceManager.<br/><br/></li>
		  <li><jump href="apidocs/org/apache/xalan/trace/TracerEvent.html">TracerEvent</jump> is an event that is 
		  passed to the TraceListener.trace function. It is called before a node is 'executed' in the stylesheet.<br/><br/></li>
		  <li><jump href="apidocs/org/apache/xalan/trace/GenerateEvent.html">GenerateEvent</jump> is an event that is 
		  passed to the TraceListener.generated() function. It is called after an event occurs to create something in the result
      tree.<br/><br/></li>
      <li><jump href="apidocs/org/apache/xalan/trace/SdelectionEvent.html">SelectionEvent</jump> is an event triggered by the
       selection of a stylesheet node.</li>
		</ul>
    <p>The <link idref="commandline">command-line utility</link> uses the debugger interface when you include one or more of the
     following switches: -TT, -TG, -TS, -TTC.</p>
    <p>Example:</p>
<source>import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.trace.TraceManager;
import org.apache.xalan.trace.PrintTraceListener;
...
// Set up a PrintTraceListener object to print to a file.
java.io.FileWriter fw = new java.io.FileWriter("events.log");
java.io.PrintWriter pw = new java.io.PrintWriter(fw);
PrintTraceListener ptl = new PrintTraceListener(pw);

// Print information as each node is 'executed' in the stylesheet.
ptl.m_traceElements = true;
// Print information after each result-tree generation event.
ptl.m_traceGeneration = true;
// Print information after each selection event.
ptl.m_traceSelection = true;
// Print information whenever a template is invoked.
ptl.m_traceTemplates = true;

// Set up the transformation
traxProcessor processor = org.apache.trax.Processor.newInstance("xslt");
org.apache.trax.Templates templates = processor.process
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(new org.xml.sax.InputSource("foo.xsl"));
org.apache.trax.Transformer transformer = templates.newTransformer();

// Cast the Transformer object as TransformerImpl.
if (transformer instanceof TransformerImpl) {
  TransformerImpl transformerImpl = (TransformerImpl)transformer;
  
  // Register the TraceListener with a TraceManager associated 
  // with the TransformerImpl.
  TraceManager trMgr = new TraceManager(transformerImpl);
  trMgr.addTraceListener(ptl);
  
  // Perform the transformation --printing information to
  // the events log during the process.
  transformer.transform
      ( new org.xml.sax.InputSource("foo.xml"), 
        new org.apache.trax.Result(new java.io.FileWriter("foo.out")) );
}
// Close the PrintWriter and FileWriter.
pw.close();
fw.close();</source>
</s2>
</s1>