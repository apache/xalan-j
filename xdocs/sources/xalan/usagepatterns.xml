<?xml version="1.0" standalone="no"?> 
<!DOCTYPE s1 SYSTEM "../../style/dtd/document.dtd">
<!--
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xalan" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, Lotus
 * Development Corporation., http://www.lotus.com.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 -->
<s1 title="Basic usage patterns">
<ul>
<li><link anchor="basic">Basic steps</link></li>
<li><link anchor="plug">Plugging in the Transformer and XML parser</link></li>
<li><link anchor="outputprops">Setting output properties in your stylesheets</link></li>
<li><link anchor="outputencoding">Caution: setting output encoding in the stylesheet</link></li>
<li><link anchor="embed">Working with embedded stylesheets</link></li>
<li><link anchor="params">Setting stylesheet parameters</link></li>
<li><link anchor="serialize">Serializing output</link></li>
<li><link anchor="sax">Explicitly working with SAX</link></li>
<li><link anchor="outasin">Using transformation output as input for another transformation</link></li>
<li><link anchor="dom">Processing and producing DOM trees</link></li>
<li><link anchor="xpath">Working with XPath expressions</link></li>
<li><link anchor="applet">Using the &xslt4j; applet wrapper</link></li>
<li><link anchor="servlet">Using &xslt4j; in a servlet</link></li>
<li><link anchor="extensions">Creating and using extensions</link></li>
<li><link anchor="multithreading">Multithreading</link></li>
<li><link anchor="debugging">Debugger interface</link></li>
<li><link anchor="compat">Using the &xslt4j; version 1 API</link> <em>[Deprecated]</em></li>
</ul>
<anchor name="basic"/>
  <s2 title="Basic steps">
    <ol>
    <li><link anchor="transformerfactory">Instantiate a TransformerFactory</link></li>
    <li><link anchor="transformer">Process the stylesheet and generate a Transformer</link></li>
    <li><link anchor="transformation">Perform the transformation</link></li>
  </ol>
    <p>The following example illustrates the three basic steps involved in performing a transformation.</p>
    <source>// 1. Instantiate a TransformerFactory.
javax.xml.transform.TransformerFactory tFactory = 
                  javax.xml.transform.TransformerFactory.newInstance();

// 2. Use the TransformerFactory to process the stylesheet Source and
//    generate a Transformer.
javax.xml.transform.Transformer transformer = tFactory.newTransformer
                (new javax.xml.transform.stream.StreamSource("foo.xsl");

// 3. Use the Transformer to transform an XML Source and send the
//    output to a Result object.
transformer.transform
    (new javax.xml.transform.stream.StreamSource("foo.xml"), 
     new javax.xml.transform.stream.StreamResult( new
                                  java.io.FileOutputStream("foo.out")));</source>
  <note>For a working example of this model at its simplest, see SimpleTransform.java in the java/samples/SimpleTransform subdirectory.</note>
  </s2><anchor name="transformerfactory"/>
  <s2 title="1. Instantiate a TransformerFactory">
  <p><jump href="apidocs/javax/xml/transform/TransformerFactory.html">TransformerFactory</jump> is an abstract class with a static newInstance() method that instantiates the concrete subclass designated by the javax.xml.transform.TransformerFactory system property.</p>
  <p>The default setting for this system property is <jump href="apidocs/org/apache/xalan/processor/TransformerFactoryImpl.html">org.apache.xalan.processor.TransformerFactoryImpl</jump>.</p>
</s2><anchor name="transformer"/>
  <s2 title="2. Use the TransformerFactory to process the stylesheet Source and produce a Transformer">
<p>The TransformerFactory <jump href="apidocs/javax/xml/transform/TransformerFactory.html#newTransformer(javax.xml.transform.Source)">newTransformer(Source xslSource)</jump> method processes the stylesheet Source into a Templates object and returns a Transformer that you can use to perform a transformation (apply the Templates object to an XML Source).</p>
<p>You may provide the stylesheet Source in the form of a stream of XML markup (<jump href="apidocs/javax/xml/transform/stream/StreamSource.html">StreamSource</jump>), a DOM Node (<jump href="apidocs/javax/xml/transform/dom/DOMSource.html">DOMSource</jump>), or a SAX InputSource (<jump href="apidocs/javax/xml/transform/sax/SAXSource.html">SAXSource</jump>). To specify a StreamSource, you may use a system ID or file name (using URI syntax), a java.io.InputStream, or a java.io.Reader. The use of DOMSource and SAXSource are illustrated in subsequent sections.</p>
<note>If you plan to use the stylesheet Source to transform multiple XML Sources, you should use the TransformerFactory <jump href="apidocs/javax/xml/transform/TransformerFactory.html#newTemplates(javax.xml.transform.Source)">newTemplates(Source xslSource)</jump> method to explicitly generate a Templates object. For each transformation, use the Templates object to generate a new Transformer. For the details, see <link anchor="multithreading">Multithreading</link>.</note>
</s2><anchor name="transformation"/>
<s2 title="3. Use the Transformer to perform a transformation">
<p>Use the Transformer <jump href="apidocs/javax/xml/transform/Transformer.html#transform(javax.xml.transform.Source,javax.xml.transform.Result">transform(Source xmlSource, Result transformResult)</jump> method to transform  the XML Source and place the transformation output in a Result object.</p>
<p>Just as with the stylesheet, you can supply the XML Source in the form of a <jump href="apidocs/javax/xml/transform/stream/StreamSource.html">StreamSource</jump>, <jump href="apidocs/javax/xml/transform/dom/DOMSource.html">DOMSource</jump>, or <jump href="apidocs/javax/xml/transform/sax/SAXSource.html">SAXSource</jump>. Likewise, the Result may be a <jump href="apidocs/javax/xml/transform/stream/StreamResult.html">StreamResult</jump>, <jump href="apidocs/javax/xml/transform/dom/DOMResult.html">DOMResult</jump>, or <jump href="apidocs/javax/xml/transform/sax/SAXResult.html">SAXResult</jump>.</p>
<p>For each node in the XML source, the Transformer uses the transformation instructions in the Templates object to determine which template to apply: one of the templates in the Templates object, a default template rule as specified in the XSLT spec, or none.</p>
</s2><anchor name="plug"/>
<s2 title="Plugging in a Transformer and XML parser">
<p>The Java API for XML Processing interfaces enable you to isolate your application from the internal implementation details of a given Transformer, SAX parser, or DOM parser. For each of these objects, there is an abstract Factory class with a static newInstance() method that instantiates a concrete Factory which wraps the underlying implementation. These newInstance() methods use system property settings to determine which implementation to instantiate.</p>
<p>&xslt4j; is distributed with a system property setting for the Xalan XSLT Transformer. This setting is in xalan.jar in META-INF/services (see src/META-INF/services).</p>
<gloss>
  <label>System property</label>
    <item>Setting</item>
  <label><code>javax.xml.transform.TransformerFactory</code></label>
   <item><code>org.apache.xalan.processor.TransformerFactoryImpl</code></item>
</gloss>
<p>If you are using Xerces, the XML parser factory settings are as follows:</p>
<gloss>
  <label>System property</label>
    <item>Setting</item>
  <label><code>javax.xml.parsers.DocumentBuilderFactory</code></label>
   <item><code>org.apache.xerces.jaxp.DocumentBuilderFactoryImpl</code></item>    
  <label><code>javax.xml.parsers.SAXParserFactory</code></label>
   <item><code>org.apache.xerces.jaxp.SAXParserFactoryImpl</code></item>
 </gloss>
<p>You can change any of these settings as follows (in order of precedence):</p>
<ol>
  <li>Set the system property from the command line when you launch Java or from within your application.<br/><br/></li>
  <li>Set the system property in jaxp.properties in the JAVA_HOME/lib directory, where JAVA_HOME is the root of the JDK.<br/><br/></li>
  <li>Revise the entry in src/META-INF/services and rebuild xalan.jar or xerces.jar (depending on which entry you have changed).<br/><br/></li>
</ol>
<p>For example, to use the Crimson XML parser in place of the Xerces XML parser, place Crimson on the class path and set the 
<code>javax.xml.parsers.SAXParserFactory</code> system property to <code>org.apache.crimson.jaxp.SAXParserFactoryImpl</code>.</p>
<p>For more information about the mechanism used to determine system property values and how you can plug other implementations into your applications, see "Section 3: Plugability Layer" in the <ref>Java API for XML Processing</ref> at 
<jump href="http://java.sun.com/aboutJava/communityprocess/review/jsr063/index.html">JSR-000063 1.1</jump>.</p> 
</s2><anchor name="outputprops"/>
<s2 title="Setting output properties in your stylesheets">
<p>Output properties for XML, HTML, and Text transformation output are defined in property files in the org.apache.xalan.templates package.</p>
<p>You can change these settings as follows:</p>
<ol>
  <li>Declare the xalan namespace in your stylesheet element (xmlns:xalan="http://xml.apache.org/xslt").<br/><br/></li>
  <li>Use the namespace prefix you assign (for example, "xalan") to redefine properties of interest in the stylesheet xsl:output
      element (for example, xalan:indent-amount="5").</li>
</ol>
<p>The following stylesheet fragment declares the xalan namespace and sets indent-amount to 2:</p>
<source>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" 
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xalan="http://xml.apache.org/xslt"&gt;
                
  &lt;xsl:output method="xml" 
              encoding="UTF-8"
              indent="yes" 
              xalan:indent-amount="2"/&gt;</source>
  <p>If you want to change the property settings globally, edit the values in the property files in src/org/apache/xalan/templates, 
  and use Ant to <link idref="readme" anchor="jar">rebuild xalan.jar</link>.</p>
<p>The properties files define the following properties:</p>
<p><ref>output_xml.properties</ref>:</p>
<table>
  <tr>
    <th>Property</th>
    <th>Default value</th>
  </tr>  
  <tr>
    <td>xalan:indent-amount</td>
    <td>0</td>
  </tr>
  <tr>
    <td>xalan:content-handler</td>
    <td>org.apache.xalan.serialize.SerializerToXML</td>
  </tr>
</table>
<p><ref>output_html.properties</ref>:</p>
<table>
  <tr>
    <th>Property</th>
    <th>Default value</th>
  </tr>  
  <tr>
    <td>xalan:indent-amount</td>
    <td>0</td>
  </tr>
  <tr>
    <td>xalan:content-handler</td>
    <td>org.apache.xalan.serialize.SerializerToHTML</td>
  </tr>
  <tr>
    <td>xalan:entities</td>
    <td>HTMLEntities.res</td>
  </tr>
  <tr>
    <td>xalan:use-url-escaping</td>
    <td>yes</td>
  </tr>
  <tr>
    <td>xalan:omit-meta-tag</td>
    <td>no</td>
  </tr>
</table>
<note>You can also create your own HTML entity file (mapping characters to entities) 
or edit src/org/apache/xalan/serialize/HTMLEntities.res and rebuild xalan.jar.</note>
<p><ref>output_text.properties</ref>:</p>
<table>  
  <tr>
    <th>Property</th>
    <th>Default value</th>
  </tr>
  <tr>
    <td>xalan:content-handler</td>
    <td>org.apache.xalan.serialize.SerializerToText</td>
  </tr>
</table>
</s2><anchor name="outputencoding"/>
<s2 title="Caution: setting output encoding in the stylesheet">
<p>When you use the &lt;xsl:output&gt; encoding attribute to set output character encoding, you should not 
use StreamResult(java.io.Writer) to construct a 
<jump href="apidocs/javax/xml/transform/stream/StreamResult.html">StreamResult</jump> object to hold the transformation result.
If you do, the Writer uses its own encoding rather than the encoding specified in the stylesheet.</p>
<p>If you want to use a Writer, you can specify an encoding when you create the Writer (java.io.OutputStreamWriter). Once the 
Writer exists, you cannot reset the encoding it uses.</p>
</s2><anchor name="embed"/>
<s2 title="Working with embedded stylesheets">
<p>An XML Source may include an <jump href="http://www.w3.org/TR/xml-stylesheet/">xml-stylesheet processing instruction</jump> which identifies the stylesheet to be used to process the document. As indicated by the processing instruction <ref>href</ref> attribute, the stylesheet itself may be embedded in the XML document or located elsewhere.</p>
<p>Suppose you have an XML document (foo.xml) with the following xml-stylesheet processing instruction:</p>
<p><code>&lt;?xml-stylesheet type="text/xml" href="foo.xsl"?&gt;</code></p>
<p>The following fragment, uses this instruction to locate the stylesheet (foo.xsl in the same directory as foo.xml) and create a Templates object. Note the use of the TransformerFactory getAssociatedStylesheet() in step 2a.</p>
<note>An XML document may include more than one xml-stylesheet processing instruction, hence the support for working with multiple stylesheets. If more than one stylesheet is returned, the other stylesheets are imported into the first stylesheet.</note>
<source>// 1. Instantiate the TransformerFactory.
javax.xml.transform.TransformerFactory tFactory = 
                    javax.xml.transform.TransformerFactory.newInstance();
// 2a. Get the stylesheet from the XML source.
String media = null , title = null, charset = null;
javax.xml.transform.Source stylesheet = tFactory.getAssociatedStylesheet
                   (new StreamSource("foo.xml"),media, title, charset);

// 2b. Process the stylesheet and generate a Transformer.
Transformer transformer = tFactory.newTransformer(stylesheet);

// 3. Use the Transformer to perform the transformation and send the
//    the output to a Result object.
transformer.transform
             (new javax.xml.transform.stream.StreamSource("foo.xml"),
              new StreamResult (new java.io.FileOutputStream("foo.out")));</source>
<p>For a sample that uses this technique, see <link idref="samples" anchor="usestylesheetpi">UseStylesheetPI</link>.</p>
<p>You can also instruct the <link idref="commandline">command-line utility</link> to use stylesheet processing
instructions:</p>
<ol>
  <li>Include the <code>-in</code> flag with an XML source that contains a stylesheet processing instruction.<br/><br/></li>
  <li>Do not include the <code>-xsl</code> flag.</li>
</ol>
</s2><anchor name="serialize"/>
<s2 title="Serializing output">
<p>In some cases, you may want to "transform" a DOM tree into a stream, which the XML community calls serialization. <link idref="trax">TRaX (Transformation API for XML)</link> and the &xslt4j; Transformer implementation provide direct support for this operation. Simply use the TransformerFactory newTransformer() method (no arguments) to create a Transformer that you can use to "copy" a DOMSource to a StreamResult. For examples, see Examples.exampleDOM2DOM(), Examples.exampleSerializeNode(), and Examples.exampleAsSerializer() in the <link idref="samples" anchor="trax">trax sample</link>.</p>
</s2><anchor name="params"/>
<s2 title="Setting stylesheet parameters">
<p>An XSLT stylesheet may include parameters that are set at run time each time a transformation is performed. To set a stylesheet parameter, use the Transformer 
<jump href="apidocs/javax/xml/transform/Transformer.html#setParameter(java.lang.String,java.lang.Object)">setParameter(String name, Object value)</jump> method. For a working example, see UseStylesheetParam.java in the samples/UseStylesheetParam subdirectory.</p>
<p>You can also set a parameter with the command-line utility by including the <code>-param</code> flag. For example:</p>
<p><code>java org.apache.xalan.xslt.Process -in foo.xml -xsl foo.xsl -param param1 foobar</code></p>
<p>where <code>param</code> is the parameter name and <code>foobar</code> is the parameter value. The parameter namespace is null.</p>
<note>&xslt4j2; processes string parameters. You are no longer required (as you were with &xslt4j; version 1) to enclose strings in single 
quotes (') as string expressions.</note>
</s2><anchor name="sax"/>
<s2 title="Explicitly working with SAX">
  <p>&xslt4j; uses the SAX event model to process stylesheets, to parse XML input documents, and to produce output. For each of these operations, an XMLReader reads input, firing parse events, and a ContentHandler listens to the XMLReader and executes parse event methods.</p>
<p>When you use the basic procedure described above for performing transformations, &xslt4j; takes care of many of the SAX details under the covers. You are free to make these details explicit, which simply means that you can intervene in the procedure to accommodate the precise environment in which your application operates.</p>
<p>Suppose, for example, you are using a custom XMLReader, perhaps doing more than just parsing static XML documents) to generate &xslt4j; SAX parse events. You might even have a custom reader for producing/processing stylesheets. You can cast the TransformerFactory to a SAXTransformerFactory, which provides access to a TransformerHandler, which you can set as the ContentHandler for this reader.</p>
  <p>The following example explicitly sets up the XMLReader and ContentHandlers, and replicates the <link anchor="basic">basic steps</link> described above.</p>
  <source>// Instantiate a TransformerFactory.
javax.xml.transform.TransformerFactory tFactory = 
                    javax.xml.transform.TransformerFactory.newInstance();
// Verify that the TransformerFactory implementation you are using
// supports SAX input and output (&xslt4j; does!).
if (tFactory.getFeature(javax.xml.transform.sax.SAXSource.FEATURE) &amp;&amp; 
    tFactory.getFeature(javax.xml.transform.sax.SAXResult.FEATURE))
  { 
    // Cast the TransformerFactory to SAXTransformerFactory.
    javax.xml.transform.sax.SAXTransformerFactory saxTFactory = 
                   ((javax.xml.transform.SAXTransformerFactory) tFactory);
    // Create a Templates ContentHandler to handle parsing of the 
    // stylesheet.
    javax.xml.transform.sax.TemplatesHandler templatesHandler = 
                                        saxTFactory.newTemplatesHandler();

    // Create an XMLReader and set its ContentHandler.
    org.xml.sax.XMLReader reader = 
                   org.xml.sax.helpers.XMLReaderFactory.createXMLReader();
    reader.setContentHandler(templatesHandler);
    
    // Parse the stylesheet.                       
    reader.parse("foo.xsl");

    // Get the Templates object (generated during the parsing of the stylesheet)
    // from the TemplatesHandler.
    javax.xml.transform.Templates templates = 
                                          templatesHandler.getTemplates();
    // Create a Transformer ContentHandler to handle parsing of 
    // the XML Source.  
    javax.xml.transform.sax.TransformerHandler transformerHandler 
                           = saxTFactory.newTransformerHandler(templates);
    // Reset the XMLReader's ContentHandler to the TransformerHandler.
    reader.setContentHandler(transformerHandler);

    // Set the ContentHandler to also function as a LexicalHandler, which
    // can process "lexical" events (such as comments and CDATA). 
    reader.setProperty("http://xml.org/sax/properties/lexical-handler", 
                        transformerHandler);

    // Set up a Serializer to serialize the Result to a file.
    org.apache.xalan.serialize.Serializer serializer = 
    org.apache.xalan.serialize.SerializerFactory.getSerializer
    (org.apache.xalan.templates.OutputProperties.getDefaultMethodProperties
                                                                   ("xml"));
    serializer.setOutputStream(new java.io.FileOutputStream("foo.out"));
    // The Serializer functions as a SAX ContentHandler.
    javax.xml.transform.Result result =
      new javax.xml.transform.sax.SAXResult(serializer.asContentHandler());
    transformerHandler.setResult(result);
      
    // Parse the XML input document.
    reader.parse("foo.xml");</source>
    <note>If you want to perform multiple transformations with the same Templates object and a TransformerHandler, you must create a new
    TransformerHandler for each transformation. The &xslt4j; implementation of TransformerHandler 
    (<jump href="src/org/apache/xalan/transformer/TransformerHandlerImpl.html">TransformerHandlerImpl</jump> fails to respond 
    to events after the first endDocument event occurs.</note>
</s2><anchor name="outasin"/>
<s2 title="Using transformation output as input for another transformation">

<p>You can chain together a series of transformations such that the output of each transformation provides input for the next transformation. &xslt4j; supports two basic strategies for chaining a series of transformations:</p>
<ul>
  <li>Use the SAXTransformerFactory to process the stylesheet and create a TransformerHandler for each transformation. Then you can set
the first TransformerHandler as the ContentHandler for the XMLReader that parses the input, make the second TransformerHandler the ContentHandler for the output of the first TransformerHandler, and so on. For more detail and an example, see the <link idref="samples" anchor="pipe">Pipe</link> sample.<br/><br/></li>
  <li>Use the SAXTransformerFactory to process the stylesheet and create a SAX XMLFilter for each transformation. Set an XMLReader as the parent of the first XMLFilter, the first XMLFilter as the parent of the second XMLFilter, and so on. You launch the series of transformations by instructing the last XMLFilter to parse the XML Source for the first transformation. For more detail and an example, see the <link idref="samples" anchor="usexmlfilters">UseXMLFilters</link> sample.</li>
</ul>
</s2><anchor name="dom"/>
<s2 title="Processing and producing DOM trees">
  <p>In some cases, the input and/or desired output for a transformation may be a DOM tree object. The javax.xml.transform.DOM package provides <jump href="apidocs/javax/xml/transform/dom/DOMSource.html">DOMSource</jump> and a <jump href="apidocs/javax/xml/transform/dom/DOMResult.html">DOMResult</jump>, either or both of which you can use when you perform a transformation.</p>
<p>In some cases, your application provides input in the form of a DOM tree, which accelerates the transformation process, since the input has in effect already been processed. To produce DOM input from a stream, you can use a <jump href="apidocs/javax/xml/parsers/DocumentBuilderFactory.html">DocumentBuilderFactory</jump> to produce a <jump href="apidocs/javax/xml/parsers/DocumentBuilder.html">DocumentBuilder</jump> with which you can parse the XML input into a DOM Document, as illustrated below.</p>
<source>// Instantiate a DocumentBuilderFactory.
javax.xml.parsers.DocumentBuilderFactory dfactory =
                    javax.xml.parsers.DocumentBuilderFactory.newInstance();
// Use the DocumentBuilderFactory to provide access to a DocumentBuilder.
javax.xml.parsers.DocumentBuilder dBuilder = dfactory.newDocumentBuilder();
// Use the DocumentBuilder to parse the XML input.
org.w3c.dom.Document inDoc = dBuilder.Parse("foo.xml");</source>
<p>To produce DOM output, simply use a Transformer to transform to a DOMResult object.</p>
<source>// Generate a Transformer.
javax.xml.transform.Transformer transformer = tFactory.newTransformer
                  (new javax.xml.transform.Stream.StreamSource("foo.xsl"));
// Create an empy DOMResult object for the output.
javax.xml.transform.dom.DOMResult domResult =
                                   new javax.xml.transform.dom.DOMResult();
// Perform the transformation.
transformer.transform(new javax.xml.transform.dom.DOMSource(inDoc)
                      domResult;
// Now you can get the output Node from the DOMResult.
org.w3c.dom.Node node = domResult.getNode();</source>
<note>Create a new DOMResult object or use DOMResult.setNode() to assign a new container each time you want to perform a transformation 
and place the output in a DOMResult object.</note>
<p>The <link idref="samples" anchor="dom2dom">DOM2DOM</link> illustrates both procedures, and serializes the DOMResult to System.out.</p>
</s2><anchor name="xpath"/>
<s2 title="Working with XPath expressions">
<p>XSLT stylesheets use XPath expressions to select nodes, specify conditions, and generate text for the result tree. XPath provides an API that you can call directly. For example, you may want to select nodes programmatically and do your own processing without a stylesheet.</p>
<p>XPath is an independent entity, with clients other than XSLT processors (such as XPointer). Accordingly, &xslt4j2; has packaged XPath as a separate module (org.apache.xpath and its subpackages), although concurrently this module does use some utility classes packaged in org.apache.xalan.utils. The org.apache.xpath.XPathAPI class contains convenience methods that you can use to return single DOM Nodes, NodeIterators, and XObjects. Apart from their own functionality, these methods also provide a path into the lower-level XPath API that you may find useful.</p>
<p>For an example that uses the XPathAPI convenience methods to execute XPath expressions against XML source files, see <link idref="samples" anchor="applyxpath">ApplyXPath</link>.</p>
</s2><anchor name="applet"/>
<s2 title="Using the &xslt4j; applet wrapper">
<ol> 
<li>Include <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html">XSLTProcessorApplet</jump> in an HTML client.<br/><br/></li>
<li>Specify the XML source document and XSL stylesheet.<br/><br/>
You can use the DocumentURL and StyleURL PARAM tags or the <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#setDocumentURL(java.lang.String)">setdocumentURL()</jump> and <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#setStyleURL(java.lang.String)">setStyleURL()</jump> methods. If the XML document contains a stylesheet Processing Instruction (PI), you do not need to specify an XSL stylesheet.<br/><br/></li>
<li>Call the <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#transformToHtml(java.lang.String,java.lang.String)">transformToHtml()</jump> or <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#getHtmlText()">getHtmlText()</jump> method, which performs the transformation and returns the new document as a String.</li></ol>
<note>The transformToHTML() method takes arguments for the XML source document and XSL stylesheet. The getHtmlText() method takes no arguments: it uses property or parameter settings, as in the example below.</note>
<p>For an example, see the <link idref="samples" anchor="appletxmltohtml">AppletXMLtoHTML</link> sample applet. The &lt;applet&gt; tag is in samples/AppletXMLtoHTML/client.html:</p>
<source>&lt;applet  
    name="xslControl"
    code="org.apache.xalan.client.XSLTProcessorApplet.class"
    archive="../../bin/xalan.jar,../../bin/xerces.jar"
    height="0"
    width"0">
    &lt;param name="documentURL" value="xalanApplets.xml"/&gt;
    &lt;param name="styleURL" value="s1ToHTML.xsl"/&gt;
&lt;/applet&gt;</source>
<p>When the user clicks the Transform button, the HTML client calls the getHtmlText() method, and puts the returned HTML text in a frame for the user to view.</p>
<p>For samples, see <link idref="samples" anchor="applet">AppletXMLtoHTML</link>.</p>
<anchor name="netscape"/><s3 title="Problems with Netscape">
    <p>The JAXP strategy of reading system properties 
    generates SecurityExceptions when you attempt to run &xslt4j; applets in the Netscape Communicator 4.7.</p> 
    <p>Stuart Connell 
    &lt;Stuart.Connell@compuware.com&gt; reports that the &xslt4j; applet wrapper does work in Netscape Communicator 6, 
    provided that you avoid calls to the AppletContext showStatus() method. In other words, you can remove the showStatus() calls
    from org.apache.xalan.client.XSLTProcessorApplet, and run &xslt4j; applets from Netscape Communicator 6. This appears to be a
    Netscape bug, which hopefully will be fixed soon. For more information, see 
    <jump href="http://nagoya.apache.org/bugzilla/show_bug.cgi?id=3231">Bugzilla bug 3231</jump>.</p>
</s3>    
</s2><anchor name="servlet"/>
<s2 title="Using &xslt4j; in a servlet">
<p>You can set up a servlet to use &xslt4j; to respond to requests for XML documents by transforming those documents into HTML and serving them to web browsers. To respond to HTTP GET requests, all you need to do is overwrite the HttpServlet doGet() method with a procedure that instantiates a Transformer and uses it to perform a transformation. As the following example shows, you can generate a ResultStream that a PrintWriter writes to the HttpResponse OutputStream, returning the transformation output to the web browser.</p>
<source>
public class SampleXSLTServlet extends javax.servlet.http.HttpServlet {
  
  // Respond to HTTP GET requests from browsers.
  public void doGet (javax.servlet.http.HttpServletRequest request,
                     javax.servlet.http.HttpServletResponse response)
    throws javax.servlet.ServletException, java.io.IOException
  {
    // Set content type for HTML.
    response.setContentType("text/html; charset=UTF-8");    
    // Output goes to the response PrintWriter.
    java.io.PrintWriter out = response.getWriter());
    try
    {	
      javax.xml.transform.TransformerFactory tFactory = 
                javax.xml.transform.TransformerFactory.newInstance();
      // Get the XML input document and the stylesheet, both in the servlet
      // engine document directory.
      javax.xml.transform.Source xmlSource = 
                new javax.xml.transform.stream.StreamSource
                             (new java.net.URL("file:foo.xml").openStream());
      javax.xml.transform.Source xslSource = 
                new javax.xml.transform.stream.StreamSource
                             (new java.net.URL("file:foo.xsl").openStream());
      // Generate the transformer.
      javax.xml.transform.Transformer transformer = 
                             tFactory.newTransformer(xslSource);
      // Perform the transformation, sending the output to the response.
      transformer.transform(xmlSource, 
                           new javax.xml.transform.stream.StreamResult(out));
    }
    // If an Exception occurs, return the error to the client.
    catch (Exception e)
    {
      out.write(e.getMessage());
      e.printStackTrace(out);    
    }
    // Close the PrintWriter.
    out.close();
  }  
}</source>
<p>For a working sample, see <link idref="samples" anchor="simplexsltservlet">SimpleXSLTServlet</link>.</p>
<p>In the preceding example, the URLs for the XML document and XSL stylesheet are hardcoded in the servlet. You can also create a servlet that parses the request URL for input parameters specifying the XML document, XSL stylesheet, and any relevant stylesheet parameters. For samples, see <link idref="samples"
anchor="usestylesheetparamservlet">UseStylesheetParamServlet</link> and <link idref="samples" anchor="xsltservletwithparams">XSLTServletWithParams</link>. For a more robust and complex sample that also employs a properties file to determine which stylesheet to use depending on the client browser/device, see <link idref="samples" anchor="applyxslt">ApplyXSLT</link>.</p>
</s2><anchor name="extensions"/>
<s2 title="Creating and using extensions">
<p>For those cases where you want to be able to call procedural code from within a stylesheet, the &xslt4j; Extensions facility supports the creation of extension elements and extension functions. See <link idref="extensions">Extensions</link> and <link idref="samples" anchor="extensions">Extensions samples</link>.</p>
</s2><anchor name="multithreading"/>
<s2 title="Multithreading">
<p>A given Templates object may be used repeatedly and even in multiple threads running concurrently for the transformation of XML input, but you should use the Templates object to instantiate a separate Transformer for each transformation you perform. The Templates object is an immutable runtime representation of the structure and content of a stylesheet (which may include and import multiple stylesheet sources). A Transformer, on the other hand, is a lightweight object that tracks state information during the transformation, and should only be used to perform a single transformation.</p>

<p>If you want to perform multiple transformations (sequentially or concurrently) with the same stylesheet instructions, do the following:</p>
<ol>
  <li>Use the TransformerFactory <jump href="apidocs/javax/xml/transform/TransformerFactory.html#newTemplates(javax.xml.transform.Source)">newTemplates(Source xslSource)</jump> method to create a Templates object.<br/><br/></li>
<li>For each transformation, use the Templates object <jump href="apidocs/javax/xml/transform/Templates.html#newTransformer()">newTransformer()</jump> method to create a Transformer, and use that Transformer's 
<jump href="apidocs/javax/xml/transform/Transformer.html#transform(javax.xml.transform.Source,javax.xml.transform.Result)">transform(Source xmlSource, Result transformResult)</jump> method to perform the transformation.</li>
</ol>
<p>For an example, see Examples.exampleUseTemplatesObj() in the <link idref="samples" anchor="trax">trax sample</link>.</p>
</s2><anchor name="debugging"/>
<s2 title="Debugger Interface">
		<p>&xslt4j; contains a debugger interface in the org.apache.xalan.xslt.trace package:</p> 
		<ul>
		  <li><jump href="apidocs/org/apache/xalan/trace/TraceListener.html">TraceListener</jump> is an interface that debuggers 
		  can implement. Or, like the <link idref="commandline">command-line utility</link>, you can use the <jump
      href="apidocs/org/apache/xalan/trace/PrintTraceListener.html">PrintTraceListener</jump> implementation of that interface.
      <br/><br/></li>
      <li>You can register a TraceListener with the 
      <jump href="apidocs/org/apache/xalan/trace/TraceManager.html">TraceManager</jump> associated
      with the Transformer that will perform a given transformation.<br/><br/></li>
		  <li><jump href="apidocs/org/apache/xalan/trace/TracerEvent.html">TracerEvent</jump> is an event that is 
		  passed to the TraceListener.trace function. It is called before a node is 'executed' in the stylesheet.<br/><br/></li>
		  <li><jump href="apidocs/org/apache/xalan/trace/GenerateEvent.html">GenerateEvent</jump> is an event that is 
		  passed to the TraceListener.generated() function. It is called after an event occurs to create something in the result
      tree.<br/><br/></li>
      <li><jump href="apidocs/org/apache/xalan/trace/SelectionEvent.html">SelectionEvent</jump> is an event triggered by the
       selection of a stylesheet node.</li>
		</ul>
    <p>The <link idref="commandline">command-line utility</link> uses the debugger interface when you include one or more of the
     following switches: <code>-TT</code>, <code>-TG</code>, <code>-TS</code>, <code>-TTC</code>.</p>
    <p>Example:</p>
<source>import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.trace.TraceManager;
import org.apache.xalan.trace.PrintTraceListener;
...
// Set up a PrintTraceListener object to print to a file.
java.io.FileWriter fw = new java.io.FileWriter("events.log");
java.io.PrintWriter pw = new java.io.PrintWriter(fw);
PrintTraceListener ptl = new PrintTraceListener(pw);

// Print information as each node is 'executed' in the stylesheet.
ptl.m_traceElements = true;
// Print information after each result-tree generation event.
ptl.m_traceGeneration = true;
// Print information after each selection event.
ptl.m_traceSelection = true;
// Print information whenever a template is invoked.
ptl.m_traceTemplates = true;

// Set up the transformation    
javax.xml.transform.TransformerFactory tFactory = 
                     javax.xml.trnasform.TransformerFactory.newInstance();
javax.xml.transform.Transformer transformer = 
  tFactory.newTransformer(new javax.xml.transform.stream.StreamSource
                                                             ("foo.xsl"));

// Cast the Transformer object to TransformerImpl.
if (transformer instanceof TransformerImpl) {
  TransformerImpl transformerImpl = (TransformerImpl)transformer;
  
  // Register the TraceListener with the TraceManager associated 
  // with the TransformerImpl.
  TraceManager trMgr = transformerImpl.getTraceManager();
  trMgr.addTraceListener(ptl);
  
  // Perform the transformation --printing information to
  // the events log during the process.
  transformer.transform
      ( new javax.xml.transform.stream.StreamSource("foo.xml"), 
        new javax.xml.transform.stream.StreamResult
                                    (new java.io.FileWriter("foo.out")) );
}
// Close the PrintWriter and FileWriter.
pw.close();
fw.close();</source>
<p>For a sample application that uses this technique, see <link idref="samples" anchor="trace">Trace</link>.</p>
</s2><anchor name="compat"/>
<s2 title="Using the &xslt4j; version 1 API">
<note><em>The compatibility jar (xalanj1compat.jar), which provides support for Xalan-Java 1 API, has been deprecated. All 
support for this API will be removed in the next releaase. If you have not already done so, we stongly urge you to shift immediately to the Xalan-Java 2/JAXP 1.1 API.</em><br/><br/> 
<em>You cannot build or run xalanj1compat.jar with with &xml4j; 2.0.0.beta3.</em><br/><br/>
<em>&xslt4j; version 1 is no longer supported and no longer available from xml.apache.org.</em></note>
<p>The bin directory includes a compatibility jar, xalanj1compat.jar, that lets you rebuild your Xalan-Java 1.x applications to run with Xalan-Java 2. As a point of reference, this JAR includes the API required to recompile the Xalan-Java 1.x core sample applications (excluding the sample extensions) and run them with Xalan-Java 2. To use this compatibility layer with an existing Xalan-Java 1.x application, do the following:</p>
<ol>
<li>Place xalanj1compat.jar on the system classpath in front of the Xalan-Java 2 xalan.jar (both are in the bin directory).<br/><br/></li>
<li>Recompile your application. It it does not compile, you may be using Xalan-Java 1.x API that the compatibility layer does not support. <br/><br/></li>
<li>Run the recompiled application with xalanj1compat.jar on the system classpath in front of the Xalan-Java 2 xalan.jar.</li>
</ol>
<p>We urge our Xalan-Java 1.x users to start using Xalan-Java 2. That is where we are concentrating our efforts to improve performance and fix any outstanding bugs. To see what portion of the Xalan-Java 1.x API we have included in xalanj1compat.jar, see <resource-ref idref="compatapi"/>. For example, the compatibility layer does not support the use of Xalan-Java 1.x extensions. If you feel that we should extend our compatibility JAR to support additional Xalan-Java 1.x API calls, please let us know exactly what you would like to see.</p>
</s2>
</s1>
