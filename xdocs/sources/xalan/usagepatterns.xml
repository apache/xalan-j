<?xml version="1.0" standalone="no"?> 
<!DOCTYPE s1 SYSTEM "sbk:/style/dtd/document.dtd">
<!--
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights 
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:  
 *       "This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/)."
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names "Xalan" and "Apache Software Foundation" must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written 
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called "Apache",
 *    nor may "Apache" appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 1999, Lotus
 * Development Corporation., http://www.lotus.com.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 -->
<s1 title="Basic usage patterns">
<ul>
<li><link anchor="basic">Basic steps</link></li>
<li><link anchor="plug">Plugging in the Transformer and XML parser</link></li>
<li><link anchor="embed">Working with embedded stylesheets</link></li>
<li><link anchor="params">Setting stylesheet parameters</link></li>
<li><link anchor="sax">Explicitly working with SAX</link></li>
<li><link anchor="outasin">Using transformation output as input for another transformation</link></li>
<li><link anchor="dom">Processing and producing DOM trees</link></li>
<li><link anchor="xpath">Working with XPath expressions</link></li>
<li><link anchor="applet">Using the &xslt4j; applet wrapper</link></li>
<li><link anchor="servlet">Using &xslt4j; in a servlet</link></li>
<li><link anchor="extensions">Creating and using extensions</link></li>
<li><link anchor="multithreading">Multithreading</link></li>
<li><link anchor="debugging">Debugger interface</link></li>
</ul>
<anchor name="basic"/>
  <s2 title="Basic steps">
    <ol>
    <li><link anchor="transformerfactory">Instantiate a TransformerFactory</link></li>
    <li><link anchor="transformer">Process the stylesheet and generate a Transformer</link></li>
    <li><link anchor="transformation">Perform the transformation</link></li>
  </ol>
    <p>The following example illustrates the three basic steps involved in performing a transformation.</p>
    <source>// 1. Instantiate a TransformerFactory.
javax.xml.transform.TransformerFactory tFactory = 
                  javax.xml.transformerTransformerFactory.newInstance();

// 2. Use the TransformerFactory to process the stylesheet Source and
//    generate a Transformer.
javax.xml.transform.Transformer transformer = tFactory.newTransformer
                (new javax.xml.transform.stream.StreamSource("foo.xsl");

// 3. Use the Transformer to transform an XML Source and send the
//    output to a Result object.
transformer.transform
    (new javax.xml.transform.stream.StreamSource("foo.xml"), 
     new javax.xml.transform.stream.StreamResult( new
                                  java.io.FileOutputStream("foo.out")));</source>
  <note>For a working example of this model at its simplest, see SimpleTransform.java in the java/samples/SimpleTransform subdirectory.</note>
  </s2><anchor name="processor"/>
  <s2 title="1. Instantiate a TransformerFactory">
  <p><jump href="apidocs/javax/xml/transform/TransformerFactory#html">TransformerFactory</jump> is an abstract class with a static newInstance() method that instantiates the concrete subclass designated by the javax.xml.transform.TransformerFactory system property.</p>
  <p>The default setting for this system property is <jump href="apidocs/org/apache/xalan/processor/TransformerFactoryImpl.html">org.apache.xalan.processor.TransformerFactoryImpl</jump>.</p>
</s2><anchor name="transformer"/>
  <s2 title="2. Use the TransformerFactory to process the stylesheet Source and produce a Transformer">
<p>The TransformerFactory <jump href="apidocs/javax/xml/transform/TransformerFactory.html#newTransformer(javax.xml.transform.Source)">newTransformer(Source xslSource)</jump> method processes the stylesheet Source into a Templates object and returns a Transformer that you can use to perform a transformation (apply the Templates object to an XML Source).</p>
<p>You may provide the stylesheet Source in the form of a stream of XML markup (<jump href="apidocs/javax/xml/transform/stream/StreamSource.html">StreamSource</jump>), a DOM Node (<jump href="apidocs/javax/xml/transform/dom/DOMSource.html">DOMSource</jump>), or a series of SAX ContentHandler events (<jump href="apidocs/javax/xml/transform/sax/SAXSource.html">SAXSource</jump>). To specify a StreamSource, you may use a system ID or file name (using URI syntax), a java.io.InputStream, or a java.io.Reader. The use of DOMSource and SAXSource are illustrated in subsequent sections.</p>
<note>If you plan to use the stylesheet Source to transform multiple XML Sources, you should use the TransformerFactory <jump href="apidocs/javax/xml/import/TransformerFactory.html#newTemplates(javax.xml.transform.Source)">newTemplates(Source xslSource)</jump> method to explicitly generate a Templates object, which you can then use repeatedly to generate a Transformer for performing an individual transformation. See <link anchor="multithreading">Multithreading</link>.</note>
</s2><anchor name="transformation"/>
<s2 title="3. Use the Transformer to perform a transformation">
<p>Use the Transformer <jump href="apidocs/javax/xml/import/Transformer.html#transform(javax.xml.transform.Source, javax.xml.transform.Result">transform(Source xmlSource, Result transformResult)</jump> method to transform  the XML Source and place the transformation output in a Result object.</p>
<p>Just as with the stylesheet, you can supply the XML Source in the form of a <jump href="apidocs/javax/xml/transform/stream/StreamSource.html">StreamSource</jump>, <jump href="apidocs/javax/xml/transform/dom/DOMSource.html">DOMSource</jump>, or <jump href="apidocs/javax/xml/transform/sax/SAXSource.html">SAXSource</jump>. Likewise, the Result may be a <jump href="apidocs/javax/xml/transform/stream/StreamResult.html">StreamResult</jump>, <jump href="apidocs/javax/xml/transform/dom/DOMResult.html">DOMResult</jump>, or <jump href="apidocs/javax/xml/transform/sax/SAXResult.html">SAXResult</jump>.</p>
<p>For each node in the XML source, the Transformer uses the transformation instructions in the Templates object to determine which template to apply: one of the templates in the Templates object, a default template rule as specified in the XSLT spec, or none.</p>
</s2><anchor name="plug"/>
<s2 title="Plugging in the Transformer and XML parser">
<p>The <jump href="apidocs/javax/xml/transform/package-summary.html">javax.xml.transform</jump> and <jump href="apidocs/javax/xml/parsers/package-summary.html">javax.xml.parsers</jump> interfaces enable you to isolate your application from the implementation details of a given Transformer, SAX parser, or DOM parser. Like javax.xml.transform.TransformerFactory, javax.xml.parsers.SAXParserFactory and javax.xml.parsers.DocumentBuilderFactory are abstract classes with a static newInstance() method that instantiates a concrete "Factory" which in turn wraps an implementation. Each of these newInstance() methods, uses a system property setting to determine the implementation to instantiate.</p>
<p>&xslt4j; is distributed with the following system property settings for the Xalan XSLT Transformer and the Xerces DOM and SAX parsers:</p>
<gloss>
  <label>System property</label>
    <item>Default value</item>
  <label><code>vax.xml.transform.TransformerFactory</code></label>
   <item><code>org.apache.xalan.proccessor.TransformerFactoryImpl</code></item>    
  <label><code>javax.xml.parsers.DocumentBuilderFactory</code></label>
   <item><code>org.apache.xerces.jaxp.DocumentBuilderFactoryImpl</code></item>    
  <label><code>javax.xml.parsers.SAXParserFactory</code></label>
   <item><code>org.apache.xerces.jaxp.SAXParserFactoryImpl</code></item>
 </gloss>  
<p>For information about the mechanism used to determine system property values, see "Section 3: Pluggability Layer" in the <ref>Java API for XML Processing</ref> at <jump href="http://java.sun.com/aboutJava/communityprocess/review/jsr063/index.html">JSR-000063 JavaTM API for XML Processing 1.1</jump>.</p> 
</s2><anchor name="embed"/>
<s2 title="Working with embedded stylesheets">
<p>An XML Source may include an <jump href="http://www.w3.org/TR/xml-stylesheet/">xml-stylesheet processing instruction</jump> which identifies the stylesheet to be used to process the document. As indicated by the processing instruction <ref>href</ref> attribute, the stylesheet itself may be embedded in the XML document or located elsewhere.</p>
<p>Suppose you have an XML document (foo.xml) with the following xml-stylesheet processing instruction:</p>
<p><code>&lt;?xml-stylesheet type="text/xml" href="foo.xsl"?&gt;</code></p>
<p>The following fragment, uses this instruction to locate the stylesheet (foo.xsl in the same directory as foo.xml) and create a Templates object. Note the use of the TransformerFactory getAssociatedStylesheet() in step 2a.</p>
<note>An XML document may include more than one xml-stylesheet processing instruction, hence the support for working with multiple stylesheets. If more than one stylesheet is returned, the other stylesheets are imported into the first stylesheet.</note>
<source>// 1. Instantiate the TransformerFactory.
javax.xml.transform.TransformerFactory tFactory = 
                    javax.xml.transform.TransformerFactory.newInstance();
// 2a. Get the stylesheet from the XML source.
String media = null , title = null, charset = null;
javax.xml.transform.Source stylesheet = tFactory.getAssociatedStylesheet
                   (new StreamSource("foo.xml"),media, title, charset);

// 2b. Process the stylesheet and generate a Transformer.
Transformer transformer = tFactory.newTransformer(stylesheet);

// 3. Use the Transformer to perform the transformation and send the
//    the output to a Result object.
transformer.transform
             (new javax.xml.transform.stream.StreamSource("foo.xml"),
              new StreamResult (new java.io.FileOutputStream("foo.out")));</source>
<p>For a sample that uses this technique, see <link idref="samples" anchor="usestylesheetpi">UseStylesheetPI</link>.</p>
<p>You can also instruct the <link idref="commandline">command-line utility</link> to use stylesheet processing
instructions:</p>
<ol>
  <li>Include the <code>-in</code> flag with an XML source that contains a stylesheet processing instruction.<br/><br/></li>
  <li>Do not include the <code>-xsl</code> flag.</li>
</ol>
</s2><anchor name="params"/>
<s2 title="Setting stylesheet parameters">
<p>An XSLT stylesheet may include parameters that are set at run time each time a transformation is performed. To set a stylesheet parameter, use the Transformer <jump href="apidocs/org/apache/trax/Transformer.html#setParameter(java.lang.String,java.lang.Object)">setParameter(String name, Object value)</jump> method. For a working example, see UseStylesheetParam.java in the samples/UseStylesheetParam subdirectory.</p>
<p>You can also set a parameter with the command-line utility by including the <code>-param</code> flag. For example:</p>
<p><code>java org.apache.xalan.xslt.Process -in foo.xml -xsl foo.xsl -param param1 foobar</code></p>
<p>where <code>param</code> is the parameter name and <code>foobar</code> is the parameter value. The parameter namespace is null.</p>
</s2><anchor name="sax"/>
<s2 title="Explicitly working with SAX">
  <p>&xslt4j; uses the SAX event model to process stylesheets, to parse XML input documents, and to produce output. For each of these operations, an XMLReader reads input, firing parse events, and a ContentHandler listens to the XMLReader and performs parse event methods.</p>
<p>When you use the basic procedure described above for performing transformations, &xslt4j; takes care of many of the SAX details under the covers. You are free to make these details explicit, which simply means that you can intervene in the procedure to accommodate the precise environment in which your application operates.</p>
<p>Suppose, for example, you are using a custom XMLReader, perhaps doing more than just parsing static XML documents) to generate &xslt4j; SAX parse events. You might even have a custom reader for producing/processing stylesheets. You can cast the TransformerFactory to a SAXTransformerFactory, which provides access to a TransformerHandler, which you can set as the ContentHandler for this reader.</p>
  <p>The following example explicitly sets up the XMLReader and ContentHandlers, and replicates the <link anchor="basic">basic steps</link> described above.</p>
  <source>// Instantiate a TransformerFactory.
javax.xml.transform.TransformerFactory tFactory = 
                    javax.xml.transform.TransformerFactory.newInstance();
// Verify that the TransformerFactory implementation you are using
// supports SAX input and output (&xslt4j; does!).
if (tFactory.getFeature(javax.xml.transform.sax.SAXSource.FEATURE) &amp;&amp; 
    tFactory.getFeature(javax.xml.transform.sax.SAXResult.FEATURE))
  { 
    // Cast the TransformerFactory to SAXTransformerFactory.
    javax.xml.transform.sax.SAXTransformerFactory saxTFactory = 
                   ((javax.xml.transform.SAXTransformerFactory) tFactory);
    // Create a Templates ContentHandler to handle parsing of the 
    // stylesheet.
    javax.xml.transform.sax.TemplatesHandler templatesHandler = 
                                        saxTFactory.newTemplatesHandler();

    // Create an XMLReader and set its ContentHandler.
    org.xml.sax.XMLReader reader = 
                   org.xml.sax.helpers.XMLReaderFactory.createXMLReader();
    reader.setContentHandler(templatesHandler);
    
    // Parse the stylesheet.                       
    reader.parse("foo.xsl");

    // Get the Templates object (generated during the parsing of the stylesheet)
    // from the TemplatesHandler.
    javax.xml.transform.Templates templates = 
                                          templatesHandler.getTemplates();
    // Create a Transformer ContentHandler to handle parsing of 
    // the XML Source.  
    javax.xml.transform.sax.TransformerHandler transformerHandler 
                           = saxTFactory.newTransformerHandler(templates);
    // Reset the XMLReader's ContentHandler to the TransformerHandler.
    reader.setContentHandler(transformerHandler);

    // Set the ContentHandler to also function as a LexicalHandler, which
    // can process "lexical" events (such as comments and CDATA). 
    reader.setProperty("http://xml.org/sax/properties/lexical-handler", 
                        transformerHandler);

    // Set up a Serializer to serialize the Result to a file.
    org.apache.xalan.serialize.Serializer serializer = 
         org.apache.xalan.serialize.SerializerFactory.getSerializer("xml");
    serializer.setOutputStream(new java.io.FileOutputStream("foo.out"));
    // The Serializer functions as a SAX ContentHandler.
    javax.xml.transform.Result result =
      new javax.xml.transform.sax.SAXResult(serializer.asContentHandler());
    transformerHandler.setResult(result);
      
    // Parse the XML input document.
    reader.parse("foo.xml");</source>
</s2><anchor name="outasin"/>
<s2 title="Using transformation output as input for another transformation">

<p>You can chain together a series of transformations such that the output of each transformation provides input for the next transformation. &xslt4j; supports two basic strategies for chaining a series of transformations:</p>
<ul>
  <li>Use the SAXTransformerFactory to process the stylesheet and create a TransformerHandler for each transformation. Then you can set
the first TransformerHandler as the ContentHandler for the XMLReader that parses the input, make the second TransformerHandler the ContentHandler for the output of the first TransformerHandler, and so on. For more detail and an example, see the <link idref="samples" anchor="pipe">Pipe</link> sample.<br/><br/></li>
  <li>Use the SAXTransformerFactory to process the stylesheet and create a SAX XMLFilter for each transformation. Set an XMLReader as the parent of the first XMLFilter, the first XMLFilter as the parent of the second XMLFilter, and so on. You launch the series of transformations by instructing the last XMLFilter to parse the XML Source for the first transformation. For more detail and an example, see the <link idref="samples" anchor="usexmlfilters">UseXMLFilters</link> sample.</li>
</ul>
</s2><anchor name="dom"/>
<s2 title="Processing and producing DOM trees">
  <p>In some cases, the input and/or desired output for a transformation may be a DOM tree object. The javax.xml.transform.DOM package provides <jump href="apidocs/javax/xml/transform/dom/DOMSource.html">DOMSource</jump> and a <jump href="apidocs/javax/xml/transform/dom/DOMResult.html">DOMResult</jump>, either or both of which you can use when you perform a transformation.</p>
<p>In some cases, your application provides input in the form of a DOM tree, which accelerates the transformation process, since the input has in effect already been processed. To produce DOM input from a stream, you can use a <jump href="apidocs/javax/xml/parsers/DocumentBuilderFactory.html">DocumentBuilderFactory</jump> to produce a <jump href="apidocs/javax/xml/parsers/DocumentBuilder.html">DocumentBuilder</jump> with which you can parse the XML input into a DOM Document, as illustrated below.</p>
<source>// Instantiate a DocumentBuilderFactory.
javax.xml.parsers.DocumentBuilderFactory dfactory =
                    javax.xml.parsers.DocumentBuilderFactory.newInstance();
// Use the DocumentBuilderFactory to provide access to a DocumentBuilder.                    
javax.xml.parsers.DocumentBuilder dBuilder = dfactory.newDocumentBuilder();
// Use the DocumentBuilder to parse the XML input.
org.w3c.dom.Document inDoc = dBuilder.Parse("foo.xml");</source>
<p>To produce DOM output, simply use a Transformer to transform to a DOMResult object.</p>
<source>// Generate a Transformer.
javax.xml.transform.Transformer transformer = tFactory.newTransformer
                  (new javax.xml.transform.Stream.StreamSource("foo.xsl"));
// Create an empy DOMResult object for the output.                  
javax.xml.transform.dom.DOMResult domResult = 
                                   new javax.xml.transform.dom.DOMResult();
// Perform the transformation.                                   
transformer.transform(new javax.xml.transform.dom.DOMSource(inDoc)
                      domResult;
// Now you can get the output Node from the DOMResult
org.w3c.dom.Node node = domResult.getNode();</source>
<p>The <link idref="samples" anchor="domtodom">TransformFromDOMtoDOM</link> illustrates both procedures, and serializes the DOMResult to System.out.</p>
</s2><anchor name="xpath"/>
<s2 title="Working with XPath expressions">
<p>XSLT stylesheets use XPath expressions to select nodes, specify conditions, and generate text for the result tree. XPath provides an API that you can call directly. For example, you may want to select nodes programmatically and do your own processing without a stylesheet.</p>
<p>XPath is an independent entity, with clients other than XSLT processors (such as XPointer). Accordingly, &xslt4j2; has packaged XPath as a separate module (org.apache.xpath and its subpackages), although concurrently this module does use some utility classes packaged in org.apache.xalan.utils. The org.apache.xpath.XPathAPI class contains convenience methods that you can use to return single DOM Nodes, NodeIterators, and XObjects. Apart from their own functionality, these methods also provide a path into the lower-level XPath API that you may find useful.</p>
<p>For an example that uses the XPathAPI convenience methods to execute XPath expressions against XML source files, see <link idref="samples" anchor="applyxpath">ApplyXPath</link>.</p>
</s2><anchor name="applet"/>
<s2 title="Using the &xslt4j; applet wrapper">
<ol> 
<li>Include <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html">XSLTProcessorApplet</jump> in an HTML client.<br/><br/></li>
<li>Specify the XML source document and XSL stylesheet.<br/><br/>
You can use the DocumentURL and StyleURL PARAM tags or the <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#setDocumentURL(java.lang.String)">setdocumentURL()</jump> and <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#setStyleURL(java.lang.String)">setStyleURL()</jump> methods. If the XML document contains a stylesheet Processing Instruction (PI), you do not need to specify an XSL stylesheet.<br/><br/></li>
<li>Call the <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#transformToHtml(java.lang.String,java.lang.String)">transformToHtml()</jump> or <jump href="apidocs/org/apache/xalan/client/XSLTProcessorApplet.html#getHtmlText()">getHtmlText()</jump> method, which performs the transformation and returns the new document as a String.</li></ol>
<note>The transformToHTML() method takes arguments for the XML source document and XSL stylesheet. The getHtmlText() method takes no arguments: it uses property or parameter settings, as in the example below.</note>
<p>For an example, see the <link idref="samples" anchor="appletxmltohtml">AppletXMLtoHTML</link> sample applet. The &lt;applet&gt; tag is in samples/AppletXMLtoHTML/client.html:</p>
<source>&lt;applet  
    name="xslControl"
    code="org.apache.xalan.client.XSLTProcessorApplet.class"
    archive="xalan.jar,xerces.jar"
    height="0"
    width"0">
    &lt;param name="documentURL" value="xalanApplets.xml"/&gt;
    &lt;param name="styleURL" value="s1ToHTML.xsl"/&gt;
&lt;/applet&gt;</source>
<p>When the user clicks the Transform button, the HTML client calls the getHtmlText() method, and puts the returned HTML text in a frame for the user to view.</p>

</s2><anchor name="servlet"/>
<s2 title="Using &xslt4j; in a servlet">
<p>You can set up a servlet to use &xslt4j; to respond to requests for XML documents by transforming those documents into HTML and serving them to clients. For a sample of how this can be done, see <link idref="samples" anchor="servlet">sample servlet</link>.</p>
</s2><anchor name="extensions"/>
<s2 title="Creating and using extensions">
<p>For those cases where you want to be able to call procedural code from within a stylesheet, the &xslt4j; Extensions facility supports the creation of extension elements and extension functions. See <link idref="extensions">Extensions</link> and <link idref="samples" anchor="extensions">Extensions samples</link>.</p>
</s2><anchor name="multithreading"/>
<s2 title="Multithreading">
<p>A given Templates object may be used repeatedly and even in multiple threads running concurrently for the transformation of XML input, but you should use the Templates object to instantiate a separate Transformer for each transformation you perform. The Templates object is an immutable runtime representation of the structure and content of a stylesheet (which may include and import multiple stylesheet sources). A Transformer, on the other hand, is a lightweight object that tracks state information during the transformation, and should only be used to perform a single transformation.</p>

<p>If you want to perform multiple transformations (sequentialy or concurrently) with the same stylesheet instructions, do the following:</p>
<ol>
  <li>Use the TransformerFactory <jump href="apidocs/javax/xml/transform/TransformerFactory.html#newTemplates(javax.xml.transform.Source)">newTemplates(Source xslSource)</jump> method to create a Templates object.<br/><br/></li>
<li>For each transformation, use the Templates object <jump href="apidocs/javax/xml/transform/Templates.html#newTransformer()">newTransformer()</jump> method to create a Transformer, and use that Transformer's <jump href="apidocs/javax/xml/transform/Transformer.html#transform(javax.xml.transform.Source, javax.xml.transform.Result)">transform(Source xmlSource, Result transformResult)</jump> method to perform the transformation.</li>
</ol>
</s2><anchor name="debugging"/>
<s2 title="Debugger Interface">
		<p>&xslt4j; contains a debugger interface in the org.apache.xalan.xslt.trace package:</p> 
		<ul>
		  <li><jump href="apidocs/org/apache/xalan/trace/TraceListener.html">TraceListener</jump> is an interface that debuggers 
		  can implement. Or, like the <link idref="commandline">command-line utility</link>, you can use the <jump
      href="apidocs/org/apache/xalan/trace/PrintTraceListener.html">PrintTraceListener</jump> implementation of that interface.
      <br/><br/></li>
      <li>You can register a TraceListener with the 
      <jump href="apidocs/org/apache/xalan/trace/TraceManager.html">TraceManager</jump> associated
      with the Transformer that will perform a given transformation.<br/><br/></li>
		  <li><jump href="apidocs/org/apache/xalan/trace/TracerEvent.html">TracerEvent</jump> is an event that is 
		  passed to the TraceListener.trace function. It is called before a node is 'executed' in the stylesheet.<br/><br/></li>
		  <li><jump href="apidocs/org/apache/xalan/trace/GenerateEvent.html">GenerateEvent</jump> is an event that is 
		  passed to the TraceListener.generated() function. It is called after an event occurs to create something in the result
      tree.<br/><br/></li>
      <li><jump href="apidocs/org/apache/xalan/trace/SdelectionEvent.html">SelectionEvent</jump> is an event triggered by the
       selection of a stylesheet node.</li>
		</ul>
    <p>The <link idref="commandline">command-line utility</link> uses the debugger interface when you include one or more of the
     following switches: <code>-TT</code>, <code>-TG</code>, <code>-TS</code>, <code>-TTC</code>.</p>
    <p>Example:</p>
<source>import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.trace.TraceManager;
import org.apache.xalan.trace.PrintTraceListener;
...
// Set up a PrintTraceListener object to print to a file.
java.io.FileWriter fw = new java.io.FileWriter("events.log");
java.io.PrintWriter pw = new java.io.PrintWriter(fw);
PrintTraceListener ptl = new PrintTraceListener(pw);

// Print information as each node is 'executed' in the stylesheet.
ptl.m_traceElements = true;
// Print information after each result-tree generation event.
ptl.m_traceGeneration = true;
// Print information after each selection event.
ptl.m_traceSelection = true;
// Print information whenever a template is invoked.
ptl.m_traceTemplates = true;

// Set up the transformation    
javax.xml.transform.TransformerFactory tFactory = 
                     javax.xml.trnasform.TransformerFactory.newInstance();
javax.xml.transform.Transformer transformer = 
  tFactory.newTransformer(new javax.xml.transform.stream.StreamSource
                                                             ("foo.xsl"));

// Cast the Transformer object to TransformerImpl.
if (transformer instanceof TransformerImpl) {
  TransformerImpl transformerImpl = (TransformerImpl)transformer;
  
  // Register the TraceListener with the TraceManager associated 
  // with the TransformerImpl.
  TraceManager trMgr = transformerImpl.getTraceManager();
  trMgr.addTraceListener(ptl);
  
  // Perform the transformation --printing information to
  // the events log during the process.
  transformer.transform
      ( new javax.xml.transform.stream.StreamSource("foo.xml"), 
        new javax.xml.transform.stream.StreamResult
                                    (new java.io.FileWriter("foo.out")) );
}
// Close the PrintWriter and FileWriter.
pw.close();
fw.close();</source>
<p>For a sample application that uses this technique, see <link idref="samples" anchor="trace">Trace</link>.</p>
</s2>
</s1>